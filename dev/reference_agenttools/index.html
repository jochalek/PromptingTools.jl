<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AgentTools · PromptingTools.jl</title><meta name="title" content="AgentTools · PromptingTools.jl"/><meta property="og:title" content="AgentTools · PromptingTools.jl"/><meta property="twitter:title" content="AgentTools · PromptingTools.jl"/><meta name="description" content="Documentation for PromptingTools.jl."/><meta property="og:description" content="Documentation for PromptingTools.jl."/><meta property="twitter:description" content="Documentation for PromptingTools.jl."/><meta property="og:url" content="https://svilupp.github.io/PromptingTools.jl/reference_agenttools/"/><meta property="twitter:url" content="https://svilupp.github.io/PromptingTools.jl/reference_agenttools/"/><link rel="canonical" href="https://svilupp.github.io/PromptingTools.jl/reference_agenttools/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PromptingTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/readme_examples/">Various examples</a></li><li><a class="tocitem" href="../examples/working_with_aitemplates/">Using AITemplates</a></li><li><a class="tocitem" href="../examples/working_with_ollama/">Local models with Ollama.ai</a></li><li><a class="tocitem" href="../examples/working_with_google_ai_studio/">Google AIStudio</a></li><li><a class="tocitem" href="../examples/working_with_custom_apis/">Custom APIs (Mistral, Llama.cpp)</a></li><li><a class="tocitem" href="../examples/building_RAG/">Building RAG Application</a></li></ul></li><li><a class="tocitem" href="../frequently_asked_questions/">F.A.Q.</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/">PromptingTools.jl</a></li><li><a class="tocitem" href="../reference_experimental/">Experimental Modules</a></li><li><a class="tocitem" href="../reference_ragtools/">RAGTools</a></li><li class="is-active"><a class="tocitem" href>AgentTools</a></li><li><a class="tocitem" href="../reference_apitools/">APITools</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>AgentTools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AgentTools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/svilupp/PromptingTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/svilupp/PromptingTools.jl/blob/main/docs/src/reference_agenttools.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-for-AgentTools"><a class="docs-heading-anchor" href="#Reference-for-AgentTools">Reference for AgentTools</a><a id="Reference-for-AgentTools-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-for-AgentTools" title="Permalink"></a></h1><ul><li><a href="#PromptingTools.Experimental.AgentTools.AICall"><code>PromptingTools.Experimental.AgentTools.AICall</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AICodeFixer"><code>PromptingTools.Experimental.AgentTools.AICodeFixer</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AIClassify-Tuple"><code>PromptingTools.Experimental.AgentTools.AIClassify</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AIEmbed-Tuple"><code>PromptingTools.Experimental.AgentTools.AIEmbed</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AIExtract-Tuple"><code>PromptingTools.Experimental.AgentTools.AIExtract</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AIGenerate-Tuple"><code>PromptingTools.Experimental.AgentTools.AIGenerate</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.AIScan-Tuple"><code>PromptingTools.Experimental.AgentTools.AIScan</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.aicodefixer_feedback-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.aicodefixer_feedback</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.remove_used_kwargs-Tuple{NamedTuple, AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.remove_used_kwargs</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.run!-Tuple{AICodeFixer}"><code>PromptingTools.Experimental.AgentTools.run!</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.run!-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}"><code>PromptingTools.Experimental.AgentTools.run!</code></a></li><li><a href="#PromptingTools.Experimental.AgentTools.truncate_conversation-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.truncate_conversation</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools" href="#PromptingTools.Experimental.AgentTools"><code>PromptingTools.Experimental.AgentTools</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">AgentTools</code></pre><p>Provides Agentic functionality providing lazy calls for building pipelines (eg, <code>AIGenerate</code>) and <code>AICodeFixer</code>.</p><p>This module is experimental and may change at any time. It is intended to be moved to a separate package in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/AgentTools.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AICall" href="#PromptingTools.Experimental.AgentTools.AICall"><code>PromptingTools.Experimental.AgentTools.AICall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AICall(func::F, args...; kwargs...) where {F&lt;:Function}

AIGenerate(args...; kwargs...)
AIEmbed(args...; kwargs...)
AIExtract(args...; kwargs...)</code></pre><p>A lazy call wrapper for AI functions in the <code>PromptingTools</code> module, such as <code>aigenerate</code>.</p><p>The <code>AICall</code> struct is designed to facilitate a deferred execution model (lazy evaluation) for AI functions that interact with a Language Learning Model (LLM). It stores the necessary information for an AI call and executes the underlying AI function only when supplied with a <code>UserMessage</code> or when the <code>run!</code> method is applied. This approach allows for more flexible and efficient handling of AI function calls, especially in interactive environments.</p><p>Seel also: <code>run!</code>, <code>AICodeFixer</code></p><p><strong>Fields</strong></p><ul><li><code>func::F</code>: The AI function to be called lazily. This should be a function like <code>aigenerate</code> or other <code>ai*</code> functions.</li><li><code>schema::Union{Nothing, PT.AbstractPromptSchema}</code>: Optional schema to structure the prompt for the AI function.</li><li><code>conversation::Vector{PT.AbstractMessage}</code>: A vector of messages that forms the conversation context for the AI call.</li><li><code>kwargs::NamedTuple</code>: Keyword arguments to be passed to the AI function.</li><li><code>success::Union{Nothing, Bool}</code>: Indicates whether the last call was successful (true) or not (false). <code>Nothing</code> if the call hasn&#39;t been made yet.</li><li><code>error::Union{Nothing, Exception}</code>: Stores any exception that occurred during the last call. <code>Nothing</code> if no error occurred or if the call hasn&#39;t been made yet.</li></ul><p><strong>Example</strong></p><p>Initiate an <code>AICall</code> like any ai* function, eg, <code>AIGenerate</code>:</p><pre><code class="language-julia hljs">aicall = AICall(aigenerate)

# With arguments and kwargs like ai* functions
# from `aigenerate(schema, conversation; model=&quot;abc&quot;, api_kwargs=(; temperature=0.1))`
# to
aicall = AICall(aigenerate, schema, conversation; model=&quot;abc&quot;, api_kwargs=(; temperature=0.1)

# Or with a template
aicall = AIGenerate(:JuliaExpertAsk; ask=&quot;xyz&quot;, model=&quot;abc&quot;, api_kwargs=(; temperature=0.1))</code></pre><p>Trigger the AICall with <code>run!</code> (it returns the update <code>AICall</code> struct back):</p><pre><code class="language-julia hljs">aicall |&gt; run!
````

You can also use `AICall` as a functor to trigger the AI call with a `UserMessage` or simply the text to send:</code></pre><p>julia aicall(UserMessage(&quot;Hello, world!&quot;))  # Triggers the lazy call result = run!(aicall)  # Explicitly runs the AI call ``` This can be used to &quot;reply&quot; to previous message / continue the stored conversation</p><p><strong>Notes</strong></p><ul><li>The <code>AICall</code> struct is a key component in building flexible and efficient Agentic pipelines</li><li>The lazy evaluation model allows for setting up the call parameters in advance and deferring the actual execution until it is explicitly triggered.</li><li>This struct is particularly useful in scenarios where the timing of AI function execution needs to be deferred or where multiple potential calls need to be prepared and selectively executed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L3-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AICodeFixer" href="#PromptingTools.Experimental.AgentTools.AICodeFixer"><code>PromptingTools.Experimental.AgentTools.AICodeFixer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AICodeFixer(aicall::AICall, templates::Vector{&lt;:PT.UserMessage}; num_rounds::Int = 3, feedback_func::Function = aicodefixer_feedback; kwargs...)
AICodeFixer(aicall::AICall, template::Union{AITemplate, Symbol} = :CodeFixerRCI; kwargs...)</code></pre><p>An AIAgent that iteratively evaluates any received Julia code and provides feedback back to the AI model if <code>num_rounds&gt;0</code>. <code>AICodeFixer</code> manages the lifecycle of a code fixing session, including tracking conversation history, rounds of interaction, and applying user feedback through a specialized feedback function.</p><p>It integrates with lazy AI call structures like <code>AIGenerate</code>. </p><p>The operation is &quot;lazy&quot;, ie, the agent is only executed when needed, eg, when <code>run!</code> is called.</p><p><strong>Fields</strong></p><ul><li><code>call::AICall</code>: The AI call that is being used for code generation or processing, eg, AIGenerate (same as <code>aigenerate</code> but &quot;lazy&quot;, ie, called only when needed</li><li><code>templates::Union{Symbol, AITemplate, Vector{PT.UserMessage}}</code>: A set of user messages or templates that guide the AI&#39;s code fixing process.  The first UserMessage is used in the first round of code fixing, the second UserMessage is used for every subsequent iteration.</li><li><code>num_rounds::Int</code>: The number of rounds for the code fixing session. Defaults to 3.</li><li><code>round_counter::Int</code>: Counter to track the current round of interaction.</li><li><code>feedback_func::Function</code>: Function to generate feedback based on the AI&#39;s proposed code, defaults to <code>aicodefixer_feedback</code>  (modular thanks to type dispatch on <code>AbstractOutcomes</code>)</li><li><code>kwargs::NamedTuple</code>: Additional keyword arguments for customizing the AI call.</li></ul><p>Note: Any kwargs provided to <code>run!()</code> will be passed to the underlying AICall.</p><p><strong>Example</strong></p><p>Let&#39;s create an AIGenerate call and then pipe it to AICodeFixer to run a few rounds of the coding fixing:</p><pre><code class="language-julia hljs"># Create an AIGenerate call
lazy_call = AIGenerate(&quot;Write a function to do XYZ...&quot;)

# the action starts only when `run!` is called
result = lazy_call |&gt; AICodeFixer |&gt; run!

# Access the result of the code fixing session
# result.call refers to the AIGenerate lazy call above
conversation = result.call.conversation
fixed_code = last(conversation) # usually in the last message

# Preview the conversation history
preview(conversation)</code></pre><p>You can change the template used to provide user feedback and number of counds via arguments:</p><pre><code class="language-julia hljs"># Setup an AIGenerate call
lazy_call = AIGenerate(aigenerate, &quot;Write code to do XYZ...&quot;)

# Custom template and 2 fixing rounds
result = AICodeFixer(lazy_call, [PT.UserMessage(&quot;Please fix the code.

Feedback: {{feedback}}&quot;)]; num_rounds = 2) |&gt; run!

# The result now contains the AI&#39;s attempts to fix the code
preview(result.call.conversation)</code></pre><p><strong>Notes</strong></p><ul><li><code>AICodeFixer</code> is particularly useful when code is hard to get right in one shot (eg, smaller models, complex syntax)</li><li>The structure leverages the lazy evaluation model of <code>AICall</code> (/AIGenerate) to efficiently manage AI interactions and be able to repeatedly call it.</li><li>The <code>run!</code> function executes the AI call and applies the feedback loop for the specified number of rounds, enabling an interactive code fixing process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L234-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AIClassify-Tuple" href="#PromptingTools.Experimental.AgentTools.AIClassify-Tuple"><code>PromptingTools.Experimental.AgentTools.AIClassify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIClassify(args...; kwargs...)</code></pre><p>Creates a lazy instance of <code>aiclassify</code>. It is an instance of <code>AICall</code> with <code>aiclassify</code> as the function.</p><p>Use exactly the same arguments and keyword arguments as <code>aiclassify</code> (see <code>?aiclassify</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AIEmbed-Tuple" href="#PromptingTools.Experimental.AgentTools.AIEmbed-Tuple"><code>PromptingTools.Experimental.AgentTools.AIEmbed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIEmbed(args...; kwargs...)</code></pre><p>Creates a lazy instance of <code>aiembed</code>. It is an instance of <code>AICall</code> with <code>aiembed</code> as the function.</p><p>Use exactly the same arguments and keyword arguments as <code>aiembed</code> (see <code>?aiembed</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L118-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AIExtract-Tuple" href="#PromptingTools.Experimental.AgentTools.AIExtract-Tuple"><code>PromptingTools.Experimental.AgentTools.AIExtract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIExtract(args...; kwargs...)</code></pre><p>Creates a lazy instance of <code>aiextract</code>. It is an instance of <code>AICall</code> with <code>aiextract</code> as the function.</p><p>Use exactly the same arguments and keyword arguments as <code>aiextract</code> (see <code>?aiextract</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AIGenerate-Tuple" href="#PromptingTools.Experimental.AgentTools.AIGenerate-Tuple"><code>PromptingTools.Experimental.AgentTools.AIGenerate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIGenerate(args...; kwargs...)</code></pre><p>Creates a lazy instance of <code>aigenerate</code>. It is an instance of <code>AICall</code> with <code>aigenerate</code> as the function.</p><p>Use exactly the same arguments and keyword arguments as <code>aigenerate</code> (see <code>?aigenerate</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.AIScan-Tuple" href="#PromptingTools.Experimental.AgentTools.AIScan-Tuple"><code>PromptingTools.Experimental.AgentTools.AIScan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIScan(args...; kwargs...)</code></pre><p>Creates a lazy instance of <code>aiscan</code>. It is an instance of <code>AICall</code> with <code>aiscan</code> as the function.</p><p>Use exactly the same arguments and keyword arguments as <code>aiscan</code> (see <code>?aiscan</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.aicodefixer_feedback-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}" href="#PromptingTools.Experimental.AgentTools.aicodefixer_feedback-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.aicodefixer_feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aicodefixer_feedback(conversation::AbstractVector{&lt;:PT.AbstractMessage}; max_length::Int = 512) -&gt; NamedTuple(; feedback::String)</code></pre><p>Generate feedback for an AI code fixing session based on the conversation history. Function is designed to be extensible for different types of feedback and code evaluation outcomes. </p><p>The highlevel wrapper accepts a conversation and returns new kwargs for the AICall.</p><p>Individual feedback functions are dispatched on different subtypes of <code>AbstractCodeOutcome</code> and can be extended/overwritten to provide more detailed feedback.</p><p>See also: <code>AIGenerate</code>, <code>AICodeFixer</code></p><p><strong>Arguments</strong></p><ul><li><code>conversation::AbstractVector{&lt;:PT.AbstractMessage}</code>: A vector of messages representing the conversation history, where the last message is expected to contain the code to be analyzed.</li><li><code>max_length::Int=512</code>: An optional argument that specifies the maximum length of the feedback message.</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: A feedback message as a kwarg in NamedTuple based on the analysis of the code provided in the conversation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">new_kwargs = aicodefixer_feedback(conversation)</code></pre><p><strong>Notes</strong></p><p>This function is part of the AI code fixing system, intended to interact with code in AIMessage and provide feedback on improving it.</p><p>The highlevel wrapper accepts a conversation and returns new kwargs for the AICall.</p><p>It dispatches for the code feedback based on the subtypes of <code>AbstractCodeOutcome</code> below:</p><ul><li><code>CodeEmpty</code>: No code found in the message.</li><li><code>CodeFailedParse</code>: Code parsing error.</li><li><code>CodeFailedEval</code>: Runtime evaluation error.</li><li><code>CodeFailedTimeout</code>: Code execution timed out.</li><li><code>CodeSuccess</code>: Successful code execution.</li></ul><p>You can override the individual methods to customize the feedback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/code_feedback.jl#L10-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.remove_used_kwargs-Tuple{NamedTuple, AbstractVector{&lt;:PromptingTools.AbstractMessage}}" href="#PromptingTools.Experimental.AgentTools.remove_used_kwargs-Tuple{NamedTuple, AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.remove_used_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Removes the kwargs that have already been used in the conversation. Returns NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/utils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.run!-Tuple{AICodeFixer}" href="#PromptingTools.Experimental.AgentTools.run!-Tuple{AICodeFixer}"><code>PromptingTools.Experimental.AgentTools.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(codefixer::AICodeFixer; verbose::Int = 1, max_conversation_length::Int = 32000, run_kwargs...)</code></pre><p>Executes the code fixing process encapsulated by the <code>AICodeFixer</code> instance.  This method iteratively refines and fixes code by running the AI call in a loop for a specified number of rounds, using feedback from the code evaluation (<code>aicodefixer_feedback</code>) to improve the outcome in each iteration.</p><p><strong>Arguments</strong></p><ul><li><code>codefixer::AICodeFixer</code>: An instance of <code>AICodeFixer</code> containing the AI call, templates, and settings for the code fixing session.</li><li><code>verbose::Int=1</code>: Verbosity level for logging. A higher value indicates more detailed logging.</li><li><code>max_conversation_length::Int=32000</code>: Maximum length in characters for the conversation history to keep it within manageable limits, especially for large code fixing sessions.</li><li><code>num_rounds::Union{Nothing, Int}=nothing</code>: Number of additional rounds for the code fixing session. If <code>nothing</code>, the value from the <code>AICodeFixer</code> instance is used.</li><li><code>run_kwargs...</code>: Additional keyword arguments that are passed to the AI function.</li></ul><p><strong>Returns</strong></p><ul><li><code>AICodeFixer</code>: The updated <code>AICodeFixer</code> instance with the results of the code fixing session.</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">aicall = AICall(aigenerate, schema=mySchema, conversation=myConversation)
codefixer = AICodeFixer(aicall, myTemplates; num_rounds=5)
result = run!(codefixer, verbose=2)</code></pre><p><strong>Notes</strong></p><ul><li>The <code>run!</code> method drives the core logic of the <code>AICodeFixer</code>, iterating through rounds of AI interactions to refine and fix code.</li><li>In each round, it applies feedback based on the current state of the conversation, allowing the AI to respond more effectively.</li><li>The conversation history is managed to ensure it stays within the specified <code>max_conversation_length</code>, keeping the AI&#39;s focus on relevant parts of the conversation.</li><li>This iterative process is essential for complex code fixing tasks where multiple interactions and refinements are required to achieve the desired outcome.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L346-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.run!-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}" href="#PromptingTools.Experimental.AgentTools.run!-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}"><code>PromptingTools.Experimental.AgentTools.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(aicall::AICallBlock; verbose::Int = 1, catch_errors::Bool = false, return_all::Bool = true, kwargs...)</code></pre><p>Executes the AI call wrapped by an <code>AICallBlock</code> instance. This method triggers the actual communication with the AI model and processes the response based on the provided conversation context and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>aicall::AICallBlock</code>: An instance of <code>AICallBlock</code> which encapsulates the AI function call along with its context and parameters (eg, <code>AICall</code>, <code>AIGenerate</code>)</li><li><code>verbose::Int=1</code>: A verbosity level for logging. A higher value indicates more detailed logging.</li><li><code>catch_errors::Bool=false</code>: If set to <code>true</code>, the method will catch and handle errors internally. Otherwise, errors are propagated.</li><li><code>return_all::Bool=true</code>: A flag to indicate whether the whole conversation from the AI call should be returned. It should always be true.</li><li><code>kwargs...</code>: Additional keyword arguments that are passed to the AI function.</li></ul><p><strong>Returns</strong></p><ul><li><code>AICallBlock</code>: The same <code>AICallBlock</code> instance, updated with the results of the AI call. This includes updated conversation, success status, and potential error information.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">aicall = AICall(aigenerate)
run!(aicall)</code></pre><p>Alternatively, you can trigger the <code>run!</code> call by using the AICall as a functor and calling it with a string or a UserMessage:</p><pre><code class="language-julia hljs">aicall = AICall(aigenerate)
aicall(&quot;Say hi!&quot;)</code></pre><p><strong>Notes</strong></p><ul><li>The <code>run!</code> method is a key component of the lazy evaluation model in <code>AICall</code>. It allows for the deferred execution of AI function calls, providing flexibility in how and when AI interactions are conducted.</li><li>The method updates the <code>AICallBlock</code> instance with the outcome of the AI call, including any generated responses, success or failure status, and error information if an error occurred.</li><li>This method is essential for scenarios where AI interactions are based on dynamic or evolving contexts, as it allows for real-time updates and responses based on the latest information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/lazy_types.jl#L157-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.Experimental.AgentTools.truncate_conversation-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}" href="#PromptingTools.Experimental.AgentTools.truncate_conversation-Tuple{AbstractVector{&lt;:PromptingTools.AbstractMessage}}"><code>PromptingTools.Experimental.AgentTools.truncate_conversation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate_conversation(conversation::AbstractVector{&lt;:PT.AbstractMessage};
    max_conversation_length::Int = 32000)</code></pre><p>Truncates a given conversation to a <code>max_conversation_length</code> characters by removing messages &quot;in the middle&quot;. It tries to retain the original system+user message and also the most recent messages.</p><p>Practically, if a conversation is too long, it will start by removing the most recent message EXCEPT for the last two (assumed to be the last AIMessage with the code and UserMessage with the feedback</p><p><strong>Arguments</strong></p><p><code>max_conversation_length</code> is in characters; assume c. 2-3 characters per LLM token, so 32000 should correspond to 16K context window.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/svilupp/PromptingTools.jl/blob/463a830a518c134b296f2b6aa031a948ed585951/src/Experimental/AgentTools/utils.jl#L13-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference_ragtools/">« RAGTools</a><a class="docs-footer-nextpage" href="../reference_apitools/">APITools »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 21:09">Thursday 22 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
