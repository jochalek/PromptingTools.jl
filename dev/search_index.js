var documenterSearchIndex = {"docs":
[{"location":"examples/working_with_google_ai_studio/#Working-with-Google-AI-Studio","page":"Google AIStudio","title":"Working with Google AI Studio","text":"","category":"section"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"This file contains examples of how to work with Google AI Studio. It is known for its Gemini models.","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"Get an API key from here. If you see a documentation page (\"Available languages and regions for Google AI Studio and Gemini API\"), it means that it's not yet available in your region.","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"Save the API key in your environment as GOOGLE_API_KEY.","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"We'll need GoogleGenAI.jl package:","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"using Pkg; Pkg.add(url=\"https://github.com/tylerjthomas9/GoogleGenAI.jl/\")","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"You can now use the Gemini-1.0-Pro model like any other model in PromptingTools. We only support aigenerate at the moment.","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"Let's import PromptingTools:","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"using PromptingTools\nconst PT = PromptingTools","category":"page"},{"location":"examples/working_with_google_ai_studio/#Text-Generation-with-aigenerate","page":"Google AIStudio","title":"Text Generation with aigenerate","text":"","category":"section"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"You can use the alias \"gemini\" for the Gemini-1.0-Pro model.","category":"page"},{"location":"examples/working_with_google_ai_studio/#Simple-message","page":"Google AIStudio","title":"Simple message","text":"","category":"section"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"msg = aigenerate(\"Say hi!\"; model = \"gemini\")","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"AIMessage(\"Hi there! As a helpful AI assistant, I'm here to help you with any questions or tasks you may have. Feel free to ask me anything, and I'll do my best to assist you.\")","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"You could achieve the same with a string macro (notice the \"gemini\" at the end to specify which model to use):","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"@ai\"Say hi!\"gemini","category":"page"},{"location":"examples/working_with_google_ai_studio/#Advanced-Prompts","page":"Google AIStudio","title":"Advanced Prompts","text":"","category":"section"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"You can provide multi-turn conversations like with any other model:","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"conversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\nmsg = aigenerate(conversation; model=\"gemini\")","category":"page"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"AIMessage(\"Young Padawan, you have stumbled into a dangerous path. Attachment leads to suffering, and love can turn to darkness. \n\nRelease your feelings for this inanimate object. \n\nThe Force flows through all living things, not machines. Seek balance in the Force, and your heart will find true connection. \n\nRemember, the path of the Jedi is to serve others, not to be attached to possessions.\")","category":"page"},{"location":"examples/working_with_google_ai_studio/#Gotchas","page":"Google AIStudio","title":"Gotchas","text":"","category":"section"},{"location":"examples/working_with_google_ai_studio/","page":"Google AIStudio","title":"Google AIStudio","text":"Gemini models actually do NOT have a system prompt (for instructions), so we simply concatenate the system and user messages together for consistency with other APIs.\nThe reported tokens in the AIMessage are actually characters (that's how Google AI Studio intends to charge for them) and are a conservative estimate that we produce. It does not matter, because at the time of writing (Feb-24), the usage is free-of-charge.","category":"page"},{"location":"examples/readme_examples/#Various-Examples","page":"Various examples","title":"Various Examples","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Noteworthy functions: aigenerate, aiembed, aiclassify, aiextract, aitemplates","category":"page"},{"location":"examples/readme_examples/#Seamless-Integration-Into-Your-Workflow","page":"Various examples","title":"Seamless Integration Into Your Workflow","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Google search is great, but it's a context switch. You often have to open a few pages and read through the discussion to find the answer you need. Same with the ChatGPT website.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Imagine you are in VSCode, editing your .gitignore file. How do I ignore a file in all subfolders again?","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"All you need to do is to type: aai\"What to write in .gitignore to ignore file XYZ in any folder or subfolder?\"","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"With aai\"\" (as opposed to ai\"\"), we make a non-blocking call to the LLM to not prevent you from continuing your work. When the answer is ready, we log it from the background:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"[ Info: Tokens: 102 @ Cost: $0.0002 in 2.7 seconds\n┌ Info: AIMessage> To ignore a file called \"XYZ\" in any folder or subfolder, you can add the following line to your .gitignore file:\n│ \n│ ```\n│ **/XYZ\n│ ```\n│ \n└ This pattern uses the double asterisk (`**`) to match any folder or subfolder, and then specifies the name of the file you want to ignore.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You probably saved 3-5 minutes on this task and probably another 5-10 minutes, because of the context switch/distraction you avoided. It's a small win, but it adds up quickly.","category":"page"},{"location":"examples/readme_examples/#Advanced-Prompts-/-Conversations","page":"Various examples","title":"Advanced Prompts / Conversations","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can use the aigenerate function to replace handlebar variables (eg, {{name}}) via keyword arguments.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aigenerate(\"Say hello to {{name}}!\", name=\"World\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"The more complex prompts are effectively a conversation (a set of messages), where you can have messages from three entities: System, User, AI Assistant. We provide the corresponding types for each of them: SystemMessage, UserMessage, AIMessage. ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"using PromptingTools: SystemMessage, UserMessage\n\nconversation = [\n    SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Jedi.\"),\n    UserMessage(\"I have feelings for my {{object}}. What should I do?\")]\nmsg = aigenerate(conversation; object = \"old iPhone\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"AIMessage(\"Ah, a dilemma, you have. Emotional attachment can cloud your path to becoming a Jedi. To be attached to material possessions, you must not. The iPhone is but a tool, nothing more. Let go, you must.\n\nSeek detachment, young padawan. Reflect upon the impermanence of all things. Appreciate the memories it gave you, and gratefully part ways. In its absence, find new experiences to grow and become one with the Force. Only then, a true Jedi, you shall become.\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can also use it to build conversations, eg, ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"new_conversation = vcat(conversation...,msg, UserMessage(\"Thank you, master Yoda! Do you have {{object}} to know what it feels like?\"))\naigenerate(new_conversation; object = \"old iPhone\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"> AIMessage(\"Hmm, possess an old iPhone, I do not. But experience with attachments, I have. Detachment, I learned. True power and freedom, it brings...\")","category":"page"},{"location":"examples/readme_examples/#Templated-Prompts","page":"Various examples","title":"Templated Prompts","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"With LLMs, the quality / robustness of your results depends on the quality of your prompts. But writing prompts is hard! That's why we offer a templating system to save you time and effort.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"To use a specific template (eg, `` to ask a Julia language):","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aigenerate(:JuliaExpertAsk; ask = \"How do I add packages?\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"The above is equivalent to a more verbose version that explicitly uses the dispatch on AITemplate:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aigenerate(AITemplate(:JuliaExpertAsk); ask = \"How do I add packages?\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Find available templates with aitemplates:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"tmps = aitemplates(\"JuliaExpertAsk\")\n# Will surface one specific template\n# 1-element Vector{AITemplateMetadata}:\n# PromptingTools.AITemplateMetadata\n#   name: Symbol JuliaExpertAsk\n#   description: String \"For asking questions about Julia language. Placeholders: `ask`\"\n#   version: String \"1\"\n#   wordcount: Int64 237\n#   variables: Array{Symbol}((1,))\n#   system_preview: String \"You are a world-class Julia language programmer with the knowledge of the latest syntax. Your commun\"\n#   user_preview: String \"# Question\\n\\n{{ask}}\"\n#   source: String \"\"","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"The above gives you a good idea of what the template is about, what placeholders are available, and how much it would cost to use it (=wordcount).","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Search for all Julia-related templates:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"tmps = aitemplates(\"Julia\")\n# 2-element Vector{AITemplateMetadata}... -> more to come later!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"If you are on VSCode, you can leverage a nice tabular display with vscodedisplay:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"using DataFrames\ntmps = aitemplates(\"Julia\") |> DataFrame |> vscodedisplay","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"I have my selected template, how do I use it? Just use the \"name\" in aigenerate or aiclassify   like you see in the first example!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can inspect any template by \"rendering\" it (this is what the LLM will see):","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"julia> AITemplate(:JudgeIsItTrue) |> PromptingTools.render","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"See more examples in the Examples folder.","category":"page"},{"location":"examples/readme_examples/#Asynchronous-Execution","page":"Various examples","title":"Asynchronous Execution","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can leverage asyncmap to run multiple AI-powered tasks concurrently, improving performance for batch operations. ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"prompts = [aigenerate(\"Translate 'Hello, World!' to {{language}}\"; language) for language in [\"Spanish\", \"French\", \"Mandarin\"]]\nresponses = asyncmap(aigenerate, prompts)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Pro tip: You can limit the number of concurrent tasks with the keyword asyncmap(...; ntasks=10).","category":"page"},{"location":"examples/readme_examples/#Model-Aliases","page":"Various examples","title":"Model Aliases","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Certain tasks require more powerful models. All user-facing functions have a keyword argument model that can be used to specify the model to be used. For example, you can use model = \"gpt-4-1106-preview\" to use the latest GPT-4 Turbo model. However, no one wants to type that!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"We offer a set of model aliases (eg, \"gpt3\", \"gpt4\", \"gpt4t\" -> the above GPT-4 Turbo, etc.) that can be used instead. ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Each ai... call first looks up the provided model name in the dictionary PromptingTools.MODEL_ALIASES, so you can easily extend with your own aliases! ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"const PT = PromptingTools\nPT.MODEL_ALIASES[\"gpt4t\"] = \"gpt-4-1106-preview\"","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"These aliases also can be used as flags in the @ai_str macro, eg, ai\"What is the capital of France?\"gpt4t (GPT-4 Turbo has a knowledge cut-off in April 2023, so it's useful for more contemporary questions).","category":"page"},{"location":"examples/readme_examples/#Embeddings","page":"Various examples","title":"Embeddings","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Use the aiembed function to create embeddings via the default OpenAI model that can be used for semantic search, clustering, and more complex AI workflows.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"text_to_embed = \"The concept of artificial intelligence.\"\nmsg = aiembed(text_to_embed)\nembedding = msg.content # 1536-element Vector{Float64}","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"If you plan to calculate the cosine distance between embeddings, you can normalize them first:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"using LinearAlgebra\nmsg = aiembed([\"embed me\", \"and me too\"], LinearAlgebra.normalize)\n\n# calculate cosine distance between the two normalized embeddings as a simple dot product\nmsg.content' * msg.content[:, 1] # [1.0, 0.787]","category":"page"},{"location":"examples/readme_examples/#Classification","page":"Various examples","title":"Classification","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can use the aiclassify function to classify any provided statement as true/false/unknown. This is useful for fact-checking, hallucination or NLI checks, moderation, filtering, sentiment analysis, feature engineering and more.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"aiclassify(\"Is two plus two four?\") \n# true","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"System prompts and higher-quality models can be used for more complex tasks, including knowing when to defer to a human:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"aiclassify(:JudgeIsItTrue; it = \"Is two plus three a vegetable on Mars?\", model = \"gpt4t\") \n# unknown","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"In the above example, we used a prompt template :JudgeIsItTrue, which automatically expands into the following system prompt (and a separate user prompt): ","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"\"You are an impartial AI judge evaluating whether the provided statement is \\\"true\\\" or \\\"false\\\". Answer \\\"unknown\\\" if you cannot decide.\"","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"For more information on templates, see the Templated Prompts section.","category":"page"},{"location":"examples/readme_examples/#Routing-to-Defined-Categories","page":"Various examples","title":"Routing to Defined Categories","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"aiclassify can be also used for classification into a set of defined categories (maximum 20), so we can use it for routing.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"In addition, if you provide the choices as tuples ((label, description)), the model will use the descriptions to decide, but it will return the labels.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Example:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"choices = [(\"A\", \"any animal or creature\"), (\"P\", \"for any plant or tree\"), (\"O\", \"for everything else\")]\n\ninput = \"spider\" \naiclassify(:InputClassifier; choices, input) # -> returns \"A\" for any animal or creature\n\n# Try also with:\ninput = \"daphodil\" # -> returns \"P\" for any plant or tree\ninput = \"castle\" # -> returns \"O\" for everything else","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Under the hood, we use the \"logit bias\" trick to force only 1 generated token - that means it's very cheap and very fast!","category":"page"},{"location":"examples/readme_examples/#Data-Extraction","page":"Various examples","title":"Data Extraction","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Are you tired of extracting data with regex? You can use LLMs to extract structured data from text!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"All you have to do is to define the structure of the data you want to extract and the LLM will do the rest.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Define a return_type with struct. Provide docstrings if needed (improves results and helps with documentation).","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Let's start with a hard task - extracting the current weather in a given location:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"@enum TemperatureUnits celsius fahrenheit\n\"\"\"Extract the current weather in a given location\n\n# Arguments\n- `location`: The city and state, e.g. \"San Francisco, CA\"\n- `unit`: The unit of temperature to return, either `celsius` or `fahrenheit`\n\"\"\"\nstruct CurrentWeather\n    location::String\n    unit::Union{Nothing,TemperatureUnits}\nend\n\n# Note that we provide the TYPE itself, not an instance of it!\nmsg = aiextract(\"What's the weather in Salt Lake City in C?\"; return_type=CurrentWeather)\nmsg.content\n# CurrentWeather(\"Salt Lake City, UT\", celsius)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"But you can use it even for more complex tasks, like extracting many entities from a text:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"\"Person's age, height, and weight.\"\nstruct MyMeasurement\n    age::Int\n    height::Union{Int,Nothing}\n    weight::Union{Nothing,Float64}\nend\nstruct ManyMeasurements\n    measurements::Vector{MyMeasurement}\nend\nmsg = aiextract(\"James is 30, weighs 80kg. He's 180cm tall. Then Jack is 19 but really tall - over 190!\"; return_type=ManyMeasurements)\nmsg.content.measurements\n# 2-element Vector{MyMeasurement}:\n#  MyMeasurement(30, 180, 80.0)\n#  MyMeasurement(19, 190, nothing)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"There is even a wrapper to help you catch errors together with helpful explanations on why parsing failed. See ?PromptingTools.MaybeExtract for more information.","category":"page"},{"location":"examples/readme_examples/#OCR-and-Image-Comprehension","page":"Various examples","title":"OCR and Image Comprehension","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"With the aiscan function, you can interact with images as if they were text.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can simply describe a provided image:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aiscan(\"Describe the image\"; image_path=\"julia.png\", model=\"gpt4v\")\n# [ Info: Tokens: 1141 @ Cost: \\$0.0117 in 2.2 seconds\n# AIMessage(\"The image shows a logo consisting of the word \"julia\" written in lowercase\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Or you can do an OCR of a screenshot.  Let's transcribe some SQL code from a screenshot (no more re-typing!), we use a template :OCRTask:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"# Screenshot of some SQL code\nimage_url = \"https://www.sqlservercentral.com/wp-content/uploads/legacy/8755f69180b7ac7ee76a69ae68ec36872a116ad4/24622.png\"\nmsg = aiscan(:OCRTask; image_url, model=\"gpt4v\", task=\"Transcribe the SQL code in the image.\", api_kwargs=(; max_tokens=2500))\n\n# [ Info: Tokens: 362 @ Cost: \\$0.0045 in 2.5 seconds\n# AIMessage(\"```sql\n# update Orders <continue>","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can add syntax highlighting of the outputs via Markdown","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"using Markdown\nmsg.content |> Markdown.parse","category":"page"},{"location":"examples/readme_examples/#Experimental-Agent-Workflows-/-Output-Validation-with-airetry!","page":"Various examples","title":"Experimental Agent Workflows / Output Validation with airetry!","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"This is an experimental feature, so you have to import it explicitly:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"using PromptingTools.Experimental.AgentTools","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"This module offers \"lazy\" counterparts to the ai... functions, so you can use them in a more controlled way, eg, aigenerate -> AIGenerate (notice the CamelCase), which has exactly the same arguments except it generates only when run! is called.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"For example:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"out = AIGenerate(\"Say hi!\"; model=\"gpt4t\")\nrun!(out)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"How is it useful? We can use the same \"inputs\" for repeated calls, eg, when we want to validate  or regenerate some outputs. We have a function airetry to help us with that.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"The signature of airetry is airetry(condition_function, aicall::AICall, feedback_function). It evaluates the condition condition_function on the aicall object (eg, we evaluate f_cond(aicall) -> Bool). If it fails, we call feedback_function on the aicall object to provide feedback for the AI model (eg, f_feedback(aicall) -> String) and repeat the process until it passes or until max_retries value is exceeded.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"We can catch API failures (no feedback needed, so none is provided)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"# API failure because of a non-existent model\n# RetryConfig allows us to change the \"retry\" behaviour of any lazy call\nout = AIGenerate(\"say hi!\"; config = RetryConfig(; catch_errors = true),\n    model = \"NOTEXIST\")\nrun!(out) # fails\n\n# we ask to wait 2s between retries and retry 2 times (can be set in `config` in aicall as well)\nairetry!(isvalid, out; retry_delay = 2, max_retries = 2)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Or we can validate some outputs (eg, its format, its content, etc.)","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"We'll play a color guessing game (I'm thinking \"yellow\"):","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"# Notice that we ask for two samples (`n_samples=2`) at each attempt (to improve our chances). \n# Both guesses are scored at each time step, and the best one is chosen for the next step.\n# And with OpenAI, we can set `api_kwargs = (;n=2)` to get both samples simultaneously (cheaper and faster)!\nout = AIGenerate(\n    \"Guess what color I'm thinking. It could be: blue, red, black, white, yellow. Answer with 1 word only\";\n    verbose = false,\n    config = RetryConfig(; n_samples = 2), api_kwargs = (; n = 2))\nrun!(out)\n\n## Check that the output is 1 word only, third argument is the feedback that will be provided if the condition fails\n## Notice: functions operate on `aicall` as the only argument. We can use utilities like `last_output` and `last_message` to access the last message and output in the conversation.\nairetry!(x -> length(split(last_output(x), r\" |\\\\.\")) == 1, out,\n    \"You must answer with 1 word only.\")\n\n# Note: you could also use the do-syntax, eg, \nairetry!(out, \"You must answer with 1 word only.\") do aicall\n    length(split(last_output(aicall), r\" |\\\\.\")) == 1\nend","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"You can place multiple airetry! calls in a sequence. They will keep retrying until they run out of maximum AI calls allowed (max_calls) or maximum retries (max_retries).","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"See the docs for more complex examples and usage tips (?airetry). We leverage Monte Carlo Tree Search (MCTS) to optimize the sequence of retries, so it's a very powerful tool for building robust AI workflows (inspired by Language Agent Tree Search paper and by DSPy Assertions paper).","category":"page"},{"location":"examples/readme_examples/#Using-Ollama-models","page":"Various examples","title":"Using Ollama models","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Ollama.ai is an amazingly simple tool that allows you to run several Large Language Models (LLM) on your computer. It's especially suitable when you're working with some sensitive data that should not be sent anywhere.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Let's assume you have installed Ollama, downloaded a model, and it's running in the background.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"We can use it with the aigenerate function:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"const PT = PromptingTools\nschema = PT.OllamaManagedSchema() # notice the different schema!\n\nmsg = aigenerate(schema, \"Say hi!\"; model=\"openhermes2.5-mistral\")\n# [ Info: Tokens: 69 in 0.9 seconds\n# AIMessage(\"Hello! How can I assist you today?\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"And we can also use the aiembed function:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aiembed(schema, \"Embed me\", copy; model=\"openhermes2.5-mistral\")\nmsg.content # 4096-element JSON3.Array{Float64...\n\nmsg = aiembed(schema, [\"Embed me\", \"Embed me\"]; model=\"openhermes2.5-mistral\")\nmsg.content # 4096×2 Matrix{Float64}:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"If you're getting errors, check that Ollama is running - see the Setup Guide for Ollama section below.","category":"page"},{"location":"examples/readme_examples/#Using-MistralAI-API-and-other-OpenAI-compatible-APIs","page":"Various examples","title":"Using MistralAI API and other OpenAI-compatible APIs","text":"","category":"section"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Mistral models have long been dominating the open-source space. They are now available via their API, so you can use them with PromptingTools.jl!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"msg = aigenerate(\"Say hi!\"; model=\"mistral-tiny\")\n# [ Info: Tokens: 114 @ Cost: $0.0 in 0.9 seconds\n# AIMessage(\"Hello there! I'm here to help answer any questions you might have, or assist you with tasks to the best of my abilities. How can I be of service to you today? If you have a specific question, feel free to ask and I'll do my best to provide accurate and helpful information. If you're looking for general assistance, I can help you find resources or information on a variety of topics. Let me know how I can help.\")","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"It all just works, because we have registered the models in the PromptingTools.MODEL_REGISTRY! There are currently 4 models available: mistral-tiny, mistral-small, mistral-medium, mistral-embed.","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Under the hood, we use a dedicated schema MistralOpenAISchema that leverages most of the OpenAI-specific code base, so you can always provide that explicitly as the first argument:","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"const PT = PromptingTools\nmsg = aigenerate(PT.MistralOpenAISchema(), \"Say Hi!\"; model=\"mistral-tiny\", api_key=ENV[\"MISTRALAI_API_KEY\"])","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"As you can see, we can load your API key either from the ENV or via the Preferences.jl mechanism (see ?PREFERENCES for more information).","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"But MistralAI are not the only ones! There are many other exciting providers, eg, Perplexity.ai, Fireworks.ai. As long as they are compatible with the OpenAI API (eg, sending messages with role and content keys), you can use them with PromptingTools.jl by using schema = CustomOpenAISchema():","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"# Set your API key and the necessary base URL for the API\napi_key = \"...\"\nprompt = \"Say hi!\"\nmsg = aigenerate(PT.CustomOpenAISchema(), prompt; model=\"my_model\", api_key, api_kwargs=(; url=\"http://localhost:8081\"))","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"As you can see, it also works for any local models that you might have running on your computer!","category":"page"},{"location":"examples/readme_examples/","page":"Various examples","title":"Various examples","text":"Note: At the moment, we only support aigenerate and aiembed functions for MistralAI and other OpenAI-compatible APIs. We plan to extend the support in the future.","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"EditURL = \"../../../examples/working_with_ollama.jl\"","category":"page"},{"location":"examples/working_with_ollama/#Local-models-with-Ollama.ai","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"This file contains examples of how to work with Ollama.ai models. It assumes that you've already installated and launched the Ollama server. For more details or troubleshooting advice, see the Frequently Asked Questions section.","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"First, let's import the package and define a helper link for calling un-exported functions:","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"using PromptingTools\nconst PT = PromptingTools","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PromptingTools","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"There were are several models from https://ollama.ai/library that we have added to our PT.MODEL_REGISTRY, which means you don't need to worry about schema changes: Eg, \"llama2\" or \"openhermes2.5-mistral\" (see PT.list_registry() and PT.list_aliases())","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Note: You must download these models prior to using them with ollama pull <model_name> in your Terminal.","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"[!TIP] If you use Apple Mac M1-3, make sure to provide api_kwargs=(; options=(; num_gpu=99)) to make sure the whole model is offloaded on your GPU. Current default is 1, which makes some models unusable. Example for running Mixtral: msg = aigenerate(PT.OllamaSchema(), \"Count from 1 to 5 and then say hi.\"; model=\"dolphin-mixtral:8x7b-v2.5-q4_K_M\", api_kwargs=(; options=(; num_gpu=99)))","category":"page"},{"location":"examples/working_with_ollama/#Text-Generation-with-aigenerate","page":"Local models with Ollama.ai","title":"Text Generation with aigenerate","text":"","category":"section"},{"location":"examples/working_with_ollama/#Simple-message","page":"Local models with Ollama.ai","title":"Simple message","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"TL;DR if you use models in PT.MODEL_REGISTRY, you don't need to add schema as the first argument:","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg = aigenerate(\"Say hi!\"; model = \"llama2\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"AIMessage(\"Hello there! *adjusts glasses* It's nice to meet you! Is there anything I can help you with or would you like me to chat with you for a bit?\")","category":"page"},{"location":"examples/working_with_ollama/#Standard-string-interpolation","page":"Local models with Ollama.ai","title":"Standard string interpolation","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"model = \"openhermes2.5-mistral\"\n\na = 1\nmsg = aigenerate(\"What is `$a+$a`?\"; model)\n\nname = \"John\"\nmsg = aigenerate(\"Say hi to {{name}}.\"; name, model)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"AIMessage(\"Hello John! *smiles* It's nice to meet you! Is there anything I can help you with today?\")","category":"page"},{"location":"examples/working_with_ollama/#Advanced-Prompts","page":"Local models with Ollama.ai","title":"Advanced Prompts","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"conversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\nmsg = aigenerate(conversation; model)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"AIMessage(\"(Deep sigh) A problem, you have. Feelings for an iPhone, hmm? (adjusts spectacles)\n\nMuch confusion, this causes. (scratches head) A being, you are. Attached to a device, you have become. (chuckles) Interesting, this is.\n\nFirst, let go, you must. (winks) Hard, it is, but necessary, yes. Distract yourself, find something else, try. (pauses)\n\nOr, perhaps, a balance, you seek? (nods) Both, enjoy and let go, the middle path, there is. (smirks) Finding joy in technology, without losing yourself, the trick, it is. (chuckles)\n\nBut fear not, young one! (grins) Help, I am here. Guide you, I will. The ways of the Yedi, teach you, I will. (winks) Patience and understanding, you must have. (nods)\n\nNow, go forth! (gestures) Explore, discover, find your balance. (smiles) The Force be with you, it does! (grins)\")","category":"page"},{"location":"examples/working_with_ollama/#Schema-Changes-/-Custom-models","page":"Local models with Ollama.ai","title":"Schema Changes / Custom models","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"If you're using some model that is not in the registry, you can either add it:","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PT.register_model!(;\n    name = \"llama123\",\n    schema = PT.OllamaSchema(),\n    description = \"Some model\")\nPT.MODEL_ALIASES[\"l123\"] = \"llama123\" # set an alias you like for it","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"\"llama123\"","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"OR define the schema explicitly (to avoid dispatch on global PT.PROMPT_SCHEMA):","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"schema = PT.OllamaSchema()\naigenerate(schema, \"Say hi!\"; model = \"llama2\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"AIMessage(\"Hello there! *smiling face* It's nice to meet you! I'm here to help you with any questions or tasks you may have, so feel free to ask me anything. Is there something specific you need assistance with today? 😊\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Note: If you only use Ollama, you can change the default schema to PT.OllamaSchema() via PT.set_preferences!(\"PROMPT_SCHEMA\" => \"OllamaSchema\", \"MODEL_CHAT\"=>\"llama2\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Restart your session and run aigenerate(\"Say hi!\") to test it.","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"! Note that in version 0.6, we've introduced OllamaSchema, which superseded OllamaManagedSchema and allows multi-turn conversations and conversations with images (eg, with Llava and Bakllava models). OllamaManagedSchema has been kept for compatibility and as an example of a schema where one provides a prompt as a string (not dictionaries like OpenAI API).","category":"page"},{"location":"examples/working_with_ollama/#Providing-Images-with-aiscan","page":"Local models with Ollama.ai","title":"Providing Images with aiscan","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"It's as simple as providing a local image path (keyword image_path). You can provide one or more images:","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg = aiscan(\"Describe the image\"; image_path=[\"julia.png\",\"python.png\"] model=\"bakllava\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"image_url keyword is not supported at the moment (use Downloads.download to download the image locally).","category":"page"},{"location":"examples/working_with_ollama/#Embeddings-with-aiembed","page":"Local models with Ollama.ai","title":"Embeddings with aiembed","text":"","category":"section"},{"location":"examples/working_with_ollama/#Simple-embedding-for-one-document","page":"Local models with Ollama.ai","title":"Simple embedding for one document","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg = aiembed(schema, \"Embed me\"; model) # access msg.content","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PromptingTools.DataMessage(JSON3.Array{Float64, Vector{UInt8}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} of size (4096,))","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"One document and we materialize the data into a Vector with copy (postprocess function argument)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg = aiembed(schema, \"Embed me\", copy; model)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PromptingTools.DataMessage(Vector{Float64} of size (4096,))","category":"page"},{"location":"examples/working_with_ollama/#Multiple-documents-embedding","page":"Local models with Ollama.ai","title":"Multiple documents embedding","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Multiple documents - embedded sequentially, you can get faster speed with async","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg = aiembed(schema, [\"Embed me\", \"Embed me\"]; model)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PromptingTools.DataMessage(Matrix{Float64} of size (4096, 2))","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"You can use Threads.@spawn or asyncmap, whichever you prefer, to paralellize the model calls","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"docs = [\"Embed me\", \"Embed me\"]\ntasks = asyncmap(docs) do doc\n    msg = aiembed(schema, doc; model)\nend\nembedding = mapreduce(x -> x.content, hcat, tasks)\nsize(embedding)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"4096×2 Matrix{Float64}:\n...","category":"page"},{"location":"examples/working_with_ollama/#Using-postprocessing-function","page":"Local models with Ollama.ai","title":"Using postprocessing function","text":"","category":"section"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Add normalization as postprocessing function to normalize embeddings on reception (for easy cosine similarity later)","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"using LinearAlgebra\nschema = PT.OllamaSchema()\n\nmsg = aiembed(schema,\n    [\"embed me\", \"and me too\"],\n    LinearAlgebra.normalize;\n    model = \"openhermes2.5-mistral\")","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"PromptingTools.DataMessage(Matrix{Float64} of size (4096, 2))","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"Cosine similarity is then a simple multiplication","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"msg.content' * msg.content[:, 1]","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"2-element Vector{Float64}:\n 0.9999999999999982\n 0.40796033843072876","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"","category":"page"},{"location":"examples/working_with_ollama/","page":"Local models with Ollama.ai","title":"Local models with Ollama.ai","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"EditURL = \"../../../examples/working_with_aitemplates.jl\"","category":"page"},{"location":"examples/working_with_aitemplates/#Using-AITemplates","page":"Using AITemplates","title":"Using AITemplates","text":"","category":"section"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"This file contains examples of how to work with AITemplate(s).","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"First, let's import the package and define a helper link for calling un-exported functions:","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"using PromptingTools\nconst PT = PromptingTools","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"PromptingTools","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"LLM responses are only as good as the prompts you give them. However, great prompts take long time to write – AITemplate are a way to re-use great prompts!","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"AITemplates are just a collection of templated prompts (ie, set of \"messages\" that have placeholders like {{question}})","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"They are saved as JSON files in the templates directory. They are automatically loaded on package import, but you can always force a re-load with PT.load_templates!()","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"PT.load_templates!();","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"You can (create them) and use them for any ai* function instead of a prompt: Let's use a template called :JuliaExpertAsk alternatively, you can use AITemplate(:JuliaExpertAsk) for cleaner dispatch","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"msg = aigenerate(:JuliaExpertAsk; ask = \"How do I add packages?\")","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"AIMessage(\"To add packages in Julia, you can use the `Pkg` module. Here are the steps:\n\n1. Start Julia by running the Julia REPL (Read-Eval-Print Loop).\n2. Press the `]` key to enter the Pkg mode.\n3. To add a package, use the `add` command followed by the package name.\n4. Press the backspace key to exit Pkg mode and return to the Julia REPL.\n\nFor example, to add the `Example` package, you would enter:\n\n```julia\n]add Example\n```\n\nAfter the package is added, you can start using it in your Julia code by using the `using` keyword. For the `Example` package, you would add the following line to your code:\n\n```julia\nusing Example\n```\n\nNote: The first time you add a package, Julia may take some time to download and compile the package and its dependencies.\")","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"You can see that it had a placeholder for the actual question (ask) that we provided as a keyword argument. We did not have to write any system prompt for personas, tone, etc. – it was all provided by the template!","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"How to know which templates are available? You can search for them with aitemplates(): You can search by Symbol (only for partial name match), String (partial match on name or description), or Regex (more fields)","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"tmps = aitemplates(\"JuliaExpertAsk\")","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"1-element Vector{AITemplateMetadata}:\nPromptingTools.AITemplateMetadata\n  name: Symbol JuliaExpertAsk\n  description: String \"For asking questions about Julia language. Placeholders: `ask`\"\n  version: String \"1\"\n  wordcount: Int64 237\n  variables: Array{Symbol}((1,))\n  system_preview: String \"You are a world-class Julia language programmer with the knowledge of the latest syntax. Your commun\"\n  user_preview: String \"# Question\\n\\n{{ask}}\"\n  source: String \"\"\n\n","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"You can see that it outputs a list of available templates that match the search - there is just one in this case.","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"Moreover, it shows not just the description, but also a preview of the actual prompts, placeholders available, and the length (to gauge how much it would cost).","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"If you use VSCode, you can display them in a nice scrollable table with vscodedisplay:","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"using DataFrames\nDataFrame(tmp) |> vscodedisplay","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"You can also just render the template to see the underlying mesages:","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"msgs = PT.render(AITemplate(:JuliaExpertAsk))","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"2-element Vector{PromptingTools.AbstractChatMessage}:\n PromptingTools.SystemMessage(\"You are a world-class Julia language programmer with the knowledge of the latest syntax. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\")\n PromptingTools.UserMessage{String}(\"# Question\\n\\n{{ask}}\", [:ask], :usermessage)","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"Now, you know exactly what's in the template!","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"If you want to modify it, simply change it and save it as a new file with save_template (see the docs ?save_template for more details).","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"Let's adjust the previous template to be more specific to a data analysis question:","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"tpl = [PT.SystemMessage(\"You are a world-class Julia language programmer with the knowledge of the latest syntax. You're also a senior Data Scientist and proficient in data analysis in Julia. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\")\n    PT.UserMessage(\"# Question\\n\\n{{ask}}\")]","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"2-element Vector{PromptingTools.AbstractChatMessage}:\n PromptingTools.SystemMessage(\"You are a world-class Julia language programmer with the knowledge of the latest syntax. You're also a senior Data Scientist and proficient in data analysis in Julia. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\")\n PromptingTools.UserMessage{String}(\"# Question\\n\\n{{ask}}\", [:ask], :usermessage)","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"Templates are saved in the templates directory of the package. Name of the file will become the template name (eg, call :JuliaDataExpertAsk)","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"filename = joinpath(pkgdir(PromptingTools),\n    \"templates\",\n    \"persona-task\",\n    \"JuliaDataExpertAsk_123.json\")\nPT.save_template(filename,\n    tpl;\n    description = \"For asking data analysis questions in Julia language. Placeholders: `ask`\")\nrm(filename) # cleanup if we don't like it","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"When you create a new template, remember to re-load the templates with load_templates!() so that it's available for use.","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"PT.load_templates!();","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"!!! If you have some good templates (or suggestions for the existing ones), please consider sharing them with the community by opening a PR to the templates directory!","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"","category":"page"},{"location":"examples/working_with_aitemplates/","page":"Using AITemplates","title":"Using AITemplates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference_experimental/#Reference-for-Experimental-Module","page":"Experimental Modules","title":"Reference for Experimental Module","text":"","category":"section"},{"location":"reference_experimental/","page":"Experimental Modules","title":"Experimental Modules","text":"Note: This module is experimental and may change in future releases.  The intention is for the functionality to be moved to separate packages over time.","category":"page"},{"location":"reference_experimental/","page":"Experimental Modules","title":"Experimental Modules","text":"Modules = [PromptingTools.Experimental]","category":"page"},{"location":"reference_experimental/","page":"Experimental Modules","title":"Experimental Modules","text":"Modules = [PromptingTools.Experimental]","category":"page"},{"location":"reference_experimental/#PromptingTools.Experimental","page":"Experimental Modules","title":"PromptingTools.Experimental","text":"Experimental\n\nThis module is for experimental code that is not yet ready for production. It is not included in the main module, so it must be explicitly imported.\n\nContains:\n\nRAGTools: Retrieval-Augmented Generation (RAG) functionality.\nAgentTools: Agentic functionality - lazy calls for building pipelines (eg, AIGenerate) and AICodeFixer.\nAPITools: APIs to complement GenAI workflows (eg, Tavily Search API).\n\n\n\n\n\n","category":"module"},{"location":"reference/#Reference","page":"PromptingTools.jl","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"PromptingTools.jl","title":"PromptingTools.jl","text":"","category":"page"},{"location":"reference/","page":"PromptingTools.jl","title":"PromptingTools.jl","text":"Modules = [PromptingTools]","category":"page"},{"location":"reference/#PromptingTools.ALLOWED_PREFERENCES","page":"PromptingTools.jl","title":"PromptingTools.ALLOWED_PREFERENCES","text":"Keys that are allowed to be set via set_preferences!\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.CONV_HISTORY","page":"PromptingTools.jl","title":"PromptingTools.CONV_HISTORY","text":"CONV_HISTORY\n\nTracks the most recent conversations through the ai_str macros.\n\nPreference available: MAXHISTORYLENGTH, which sets how many last messages should be remembered.\n\nSee also: push_conversation!, resize_conversation!\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.MODEL_ALIASES","page":"PromptingTools.jl","title":"PromptingTools.MODEL_ALIASES","text":"MODEL_ALIASES\n\nA dictionary of model aliases. Aliases are used to refer to models by their aliases instead of their full names to make it more convenient to use them.\n\nAccessing the aliases\n\nPromptingTools.MODEL_ALIASES[\"gpt3\"]\n\nRegister a new model alias\n\nPromptingTools.MODEL_ALIASES[\"gpt3\"] = \"gpt-3.5-turbo\"\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.MODEL_REGISTRY","page":"PromptingTools.jl","title":"PromptingTools.MODEL_REGISTRY","text":"MODEL_REGISTRY\n\nA store of available model names and their specs (ie, name, costs per token, etc.)\n\nAccessing the registry\n\nYou can use both the alias name or the full name to access the model spec:\n\nPromptingTools.MODEL_REGISTRY[\"gpt-3.5-turbo\"]\n\nRegistering a new model\n\nregister_model!(\n    name = \"gpt-3.5-turbo\",\n    schema = :OpenAISchema,\n    cost_of_token_prompt = 0.0015,\n    cost_of_token_generation = 0.002,\n    description = \"GPT-3.5 Turbo is a 175B parameter model and a common default on the OpenAI API.\")\n\nRegistering a model alias\n\nPromptingTools.MODEL_ALIASES[\"gpt3\"] = \"gpt-3.5-turbo\"\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.OPENAI_TOKEN_IDS","page":"PromptingTools.jl","title":"PromptingTools.OPENAI_TOKEN_IDS","text":"Token IDs for GPT3.5 and GPT4 from https://platform.openai.com/tokenizer\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.PREFERENCES","page":"PromptingTools.jl","title":"PromptingTools.PREFERENCES","text":"PREFERENCES\n\nYou can set preferences for PromptingTools by setting environment variables (for OPENAI_API_KEY only)      or by using the set_preferences!.     It will create a LocalPreferences.toml file in your current directory and will reload your prefences from there.\n\nCheck your preferences by calling get_preferences(key::String).\n\nAvailable Preferences (for set_preferences!)\n\nOPENAI_API_KEY: The API key for the OpenAI API. See OpenAI's documentation for more information.\nMISTRALAI_API_KEY: The API key for the Mistral AI API. See Mistral AI's documentation for more information.\nCOHERE_API_KEY: The API key for the Cohere API. See Cohere's documentation for more information.\nDATABRICKS_API_KEY: The API key for the Databricks Foundation Model API. See Databricks' documentation for more information.\nDATABRICKS_HOST: The host for the Databricks API. See Databricks' documentation for more information.\nTAVILY_API_KEY: The API key for the Tavily Search API. Register here. See more information here.\nGOOGLE_API_KEY: The API key for Google Gemini models. Get yours from here. If you see a documentation page (\"Available languages and regions for Google AI Studio and Gemini API\"), it means that it's not yet available in your region.\nMODEL_CHAT: The default model to use for aigenerate and most ai* calls. See MODEL_REGISTRY for a list of available models or define your own.\nMODEL_EMBEDDING: The default model to use for aiembed (embedding documents). See MODEL_REGISTRY for a list of available models or define your own.\nPROMPT_SCHEMA: The default prompt schema to use for aigenerate and most ai* calls (if not specified in MODEL_REGISTRY). Set as a string, eg, \"OpenAISchema\".   See PROMPT_SCHEMA for more information.\nMODEL_ALIASES: A dictionary of model aliases (alias => full_model_name). Aliases are used to refer to models by their aliases instead of their full names to make it more convenient to use them.   See MODEL_ALIASES for more information.\nMAX_HISTORY_LENGTH: The maximum length of the conversation history. Defaults to 5. Set to nothing to disable history.   See CONV_HISTORY for more information.\nLOCAL_SERVER: The URL of the local server to use for ai* calls. Defaults to http://localhost:10897/v1. This server is called when you call model=\"local\"   See ?LocalServerOpenAISchema for more information and examples.\n\nAt the moment it is not possible to persist changes to MODEL_REGISTRY across sessions.  Define your register_model!() calls in your startup.jl file to make them available across sessions or put them at the top of your script.\n\nAvailable ENV Variables\n\nOPENAI_API_KEY: The API key for the OpenAI API. \nMISTRALAI_API_KEY: The API key for the Mistral AI API.\nCOHERE_API_KEY: The API key for the Cohere API.\nLOCAL_SERVER: The URL of the local server to use for ai* calls. Defaults to http://localhost:10897/v1. This server is called when you call model=\"local\"\nDATABRICKS_API_KEY: The API key for the Databricks Foundation Model API.\nDATABRICKS_HOST: The host for the Databricks API.\nTAVILY_API_KEY: The API key for the Tavily Search API. Register here. See more information here.\nGOOGLE_API_KEY: The API key for Google Gemini models. Get yours from here. If you see a documentation page (\"Available languages and regions for Google AI Studio and Gemini API\"), it means that it's not yet available in your region.\n\nPreferences.jl takes priority over ENV variables, so if you set a preference, it will take precedence over the ENV variable.\n\nWARNING: NEVER EVER sync your LocalPreferences.toml file! It contains your API key and other sensitive information!!!\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.RESERVED_KWARGS","page":"PromptingTools.jl","title":"PromptingTools.RESERVED_KWARGS","text":"The following keywords are reserved for internal use in the ai* functions and cannot be used as placeholders in the Messages\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PromptingTools.AICode","page":"PromptingTools.jl","title":"PromptingTools.AICode","text":"AICode(code::AbstractString; auto_eval::Bool=true, safe_eval::Bool=false, \nskip_unsafe::Bool=false, capture_stdout::Bool=true, verbose::Bool=false,\nprefix::AbstractString=\"\", suffix::AbstractString=\"\", remove_tests::Bool=false, execution_timeout::Int = 60)\n\nAICode(msg::AIMessage; auto_eval::Bool=true, safe_eval::Bool=false, \nskip_unsafe::Bool=false, skip_invalid::Bool=false, capture_stdout::Bool=true,\nverbose::Bool=false, prefix::AbstractString=\"\", suffix::AbstractString=\"\", remove_tests::Bool=false, execution_timeout::Int = 60)\n\nA mutable structure representing a code block (received from the AI model) with automatic parsing, execution, and output/error capturing capabilities.\n\nUpon instantiation with a string, the AICode object automatically runs a code parser and executor (via PromptingTools.eval!()), capturing any standard output (stdout) or errors.  This structure is useful for programmatically handling and evaluating Julia code snippets.\n\nSee also: PromptingTools.extract_code_blocks, PromptingTools.eval!\n\nWorkflow\n\nUntil cb::AICode has been evaluated, cb.success is set to nothing (and so are all other fields).\nThe text in cb.code is parsed (saved to cb.expression).\nThe parsed expression is evaluated.\nOutputs of the evaluated expression are captured in cb.output.\nAny stdout outputs (e.g., from println) are captured in cb.stdout.\nIf an error occurs during evaluation, it is saved in cb.error.\nAfter successful evaluation without errors, cb.success is set to true.  Otherwise, it is set to false and you can inspect the cb.error to understand why.\n\nProperties\n\ncode::AbstractString: The raw string of the code to be parsed and executed.\nexpression: The parsed Julia expression (set after parsing code).\nstdout: Captured standard output from the execution of the code.\noutput: The result of evaluating the code block.\nsuccess::Union{Nothing, Bool}: Indicates whether the code block executed successfully (true), unsuccessfully (false), or has yet to be evaluated (nothing).\nerror::Union{Nothing, Exception}: Any exception raised during the execution of the code block.\n\nKeyword Arguments\n\nauto_eval::Bool: If set to true, the code block is automatically parsed and evaluated upon instantiation. Defaults to true.\nsafe_eval::Bool: If set to true, the code block checks for package operations (e.g., installing new packages) and missing imports, and then evaluates the code inside a bespoke scratch module. This is to ensure that the evaluation does not alter any user-defined variables or the global state. Defaults to false.\nskip_unsafe::Bool: If set to true, we skip any lines in the code block that are deemed unsafe (eg, Pkg operations). Defaults to false.\nskip_invalid::Bool: If set to true, we skip code blocks that do not even parse. Defaults to false.\nverbose::Bool: If set to true, we print out any lines that are skipped due to being unsafe. Defaults to false.\ncapture_stdout::Bool: If set to true, we capture any stdout outputs (eg, test failures) in cb.stdout. Defaults to true.\nprefix::AbstractString: A string to be prepended to the code block before parsing and evaluation. Useful to add some additional code definition or necessary imports. Defaults to an empty string.\nsuffix::AbstractString: A string to be appended to the code block before parsing and evaluation.  Useful to check that tests pass or that an example executes. Defaults to an empty string.\nremove_tests::Bool: If set to true, we remove any @test or @testset macros from the code block before parsing and evaluation. Defaults to false.\nexecution_timeout::Int: The maximum time (in seconds) allowed for the code block to execute. Defaults to 60 seconds.\n\nMethods\n\nBase.isvalid(cb::AICode): Check if the code block has executed successfully. Returns true if cb.success == true.\n\nExamples\n\ncode = AICode(\"println(\"Hello, World!\")\") # Auto-parses and evaluates the code, capturing output and errors.\nisvalid(code) # Output: true\ncode.stdout # Output: \"Hello, World!\n\"\n\nWe try to evaluate \"safely\" by default (eg, inside a custom module, to avoid changing user variables).   You can avoid that with save_eval=false:\n\ncode = AICode(\"new_variable = 1\"; safe_eval=false)\nisvalid(code) # Output: true\nnew_variable # Output: 1\n\nYou can also call AICode directly on an AIMessage, which will extract the Julia code blocks, concatenate them and evaluate them:\n\nmsg = aigenerate(\"In Julia, how do you create a vector of 10 random numbers?\")\ncode = AICode(msg)\n# Output: AICode(Success: True, Parsed: True, Evaluated: True, Error Caught: N/A, StdOut: True, Code: 2 Lines)\n\n# show the code\ncode.code |> println\n# Output: \n# numbers = rand(10)\n# numbers = rand(1:100, 10)\n\n# or copy it to the clipboard\ncode.code |> clipboard\n\n# or execute it in the current module (=Main)\neval(code.expression)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.AIMessage","page":"PromptingTools.jl","title":"PromptingTools.AIMessage","text":"AIMessage\n\nA message type for AI-generated text-based responses.  Returned by aigenerate, aiclassify, and aiscan functions.\n\nFields\n\ncontent::Union{AbstractString, Nothing}: The content of the message.\nstatus::Union{Int, Nothing}: The status of the message from the API.\ntokens::Tuple{Int, Int}: The number of tokens used (prompt,completion).\nelapsed::Float64: The time taken to generate the response in seconds.\ncost::Union{Nothing, Float64}: The cost of the API call (calculated with information from MODEL_REGISTRY).\nlog_prob::Union{Nothing, Float64}: The log probability of the response.\nfinish_reason::Union{Nothing, String}: The reason the response was finished.\nrun_id::Union{Nothing, Int}: The unique ID of the run.\nsample_id::Union{Nothing, Int}: The unique ID of the sample (if multiple samples are generated, they will all have the same run_id).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.AITemplate","page":"PromptingTools.jl","title":"PromptingTools.AITemplate","text":"AITemplate\n\nAITemplate is a template for a conversation prompt.   This type is merely a container for the template name, which is resolved into a set of messages (=prompt) by render.\n\nNaming Convention\n\nTemplate names should be in CamelCase\nFollow the format <Persona>...<Variable>... where possible, eg, JudgeIsItTrue, ``\nStarting with the Persona (=System prompt), eg, Judge = persona is meant to judge some provided information\nVariable to be filled in with context, eg, It = placeholder it\nEnding with the variable name is helpful, eg, JuliaExpertTask for a persona to be an expert in Julia language and task is the placeholder name\nIdeally, the template name should be self-explanatory, eg, JudgeIsItTrue = persona is meant to judge some provided information where it is true or false\n\nExamples\n\nSave time by re-using pre-made templates, just fill in the placeholders with the keyword arguments:\n\nmsg = aigenerate(:JuliaExpertAsk; ask = \"How do I add packages?\")\n\nThe above is equivalent to a more verbose version that explicitly uses the dispatch on AITemplate:\n\nmsg = aigenerate(AITemplate(:JuliaExpertAsk); ask = \"How do I add packages?\")\n\nFind available templates with aitemplates:\n\ntmps = aitemplates(\"JuliaExpertAsk\")\n# Will surface one specific template\n# 1-element Vector{AITemplateMetadata}:\n# PromptingTools.AITemplateMetadata\n#   name: Symbol JuliaExpertAsk\n#   description: String \"For asking questions about Julia language. Placeholders: `ask`\"\n#   version: String \"1\"\n#   wordcount: Int64 237\n#   variables: Array{Symbol}((1,))\n#   system_preview: String \"You are a world-class Julia language programmer with the knowledge of the latest syntax. Your commun\"\n#   user_preview: String \"# Question\n\n{{ask}}\"\n#   source: String \"\"\n\nThe above gives you a good idea of what the template is about, what placeholders are available, and how much it would cost to use it (=wordcount).\n\nSearch for all Julia-related templates:\n\ntmps = aitemplates(\"Julia\")\n# 2-element Vector{AITemplateMetadata}... -> more to come later!\n\nIf you are on VSCode, you can leverage nice tabular display with vscodedisplay:\n\nusing DataFrames\ntmps = aitemplates(\"Julia\") |> DataFrame |> vscodedisplay\n\nI have my selected template, how do I use it? Just use the \"name\" in aigenerate or aiclassify   like you see in the first example!\n\nYou can inspect any template by \"rendering\" it (this is what the LLM will see):\n\njulia> AITemplate(:JudgeIsItTrue) |> PromptingTools.render\n\nSee also: save_template, load_template, load_templates! for more advanced use cases (and the corresponding script in examples/ folder)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.AITemplateMetadata","page":"PromptingTools.jl","title":"PromptingTools.AITemplateMetadata","text":"Helper for easy searching and reviewing of templates. Defined on loading of each template.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.AbstractPromptSchema","page":"PromptingTools.jl","title":"PromptingTools.AbstractPromptSchema","text":"Defines different prompting styles based on the model training and fine-tuning.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.ChatMLSchema","page":"PromptingTools.jl","title":"PromptingTools.ChatMLSchema","text":"ChatMLSchema is used by many open-source chatbots, by OpenAI models (under the hood) and by several models and inferfaces (eg, Ollama, vLLM)\n\nYou can explore it on tiktokenizer\n\nIt uses the following conversation structure:\n\n<im_start>system\n...<im_end>\n<|im_start|>user\n...<|im_end|>\n<|im_start|>assistant\n...<|im_end|>\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.CustomOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.CustomOpenAISchema","text":"CustomOpenAISchema\n\nCustomOpenAISchema() allows user to call any OpenAI-compatible API.\n\nAll user needs to do is to pass this schema as the first argument and provide the BASE URL of the API to call (api_kwargs.url).\n\nExample\n\nAssumes that we have a local server running at http://127.0.0.1:8081:\n\napi_key = \"...\"\nprompt = \"Say hi!\"\nmsg = aigenerate(CustomOpenAISchema(), prompt; model=\"my_model\", api_key, api_kwargs=(; url=\"http://127.0.0.1:8081\"))\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.DataMessage","page":"PromptingTools.jl","title":"PromptingTools.DataMessage","text":"DataMessage\n\nA message type for AI-generated data-based responses, ie, different content than text.  Returned by aiextract, and aiextract functions.\n\nFields\n\ncontent::Union{AbstractString, Nothing}: The content of the message.\nstatus::Union{Int, Nothing}: The status of the message from the API.\ntokens::Tuple{Int, Int}: The number of tokens used (prompt,completion).\nelapsed::Float64: The time taken to generate the response in seconds.\ncost::Union{Nothing, Float64}: The cost of the API call (calculated with information from MODEL_REGISTRY).\nlog_prob::Union{Nothing, Float64}: The log probability of the response.\nfinish_reason::Union{Nothing, String}: The reason the response was finished.\nrun_id::Union{Nothing, Int}: The unique ID of the run.\nsample_id::Union{Nothing, Int}: The unique ID of the sample (if multiple samples are generated, they will all have the same run_id).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.DatabricksOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.DatabricksOpenAISchema","text":"DatabricksOpenAISchema\n\nDatabricksOpenAISchema() allows user to call Databricks Foundation Model API. API Reference\n\nRequires two environment variables to be set:\n\nDATABRICKS_API_KEY: Databricks token\nDATABRICKS_HOST: Address of the Databricks workspace (https://<workspace_host>.databricks.com)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.FireworksOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.FireworksOpenAISchema","text":"FireworksOpenAISchema\n\nSchema to call the Fireworks.ai API.\n\nLinks:\n\nGet your API key\nAPI Reference\nAvailable models\n\nRequires one environment variables to be set:\n\nFIREWORKS_API_KEY: Your API key\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.GoogleSchema","page":"PromptingTools.jl","title":"PromptingTools.GoogleSchema","text":"Calls Google's Gemini API. See more information here. It's available only for some regions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.ItemsExtract","page":"PromptingTools.jl","title":"PromptingTools.ItemsExtract","text":"Extract zero, one or more specified items from the provided data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.LocalServerOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.LocalServerOpenAISchema","text":"LocalServerOpenAISchema\n\nDesigned to be used with local servers. It's automatically called with model alias \"local\" (see MODEL_REGISTRY).\n\nThis schema is a flavor of CustomOpenAISchema with a url keypreset by global Preference keyLOCAL_SERVER. See?PREFERENCESfor more details on how to change it. It assumes that the server follows OpenAI API conventions (eg,POST /v1/chat/completions`).\n\nNote: Llama.cpp (and hence Llama.jl built on top of it) do NOT support embeddings endpoint! You'll get an address error.\n\nExample\n\nAssumes that we have a local server running at http://127.0.0.1:10897/v1 (port and address used by Llama.jl, \"v1\" at the end is needed for OpenAI endpoint compatibility):\n\nThree ways to call it:\n\n\n# Use @ai_str with \"local\" alias\nai\"Say hi!\"local\n\n# model=\"local\"\naigenerate(\"Say hi!\"; model=\"local\")\n\n# Or set schema explicitly\nconst PT = PromptingTools\nmsg = aigenerate(PT.LocalServerOpenAISchema(), \"Say hi!\")\n\nHow to start a LLM local server? You can use run_server function from Llama.jl. Use a separate Julia session.\n\nusing Llama\nmodel = \"...path...\" # see Llama.jl README how to download one\nrun_server(; model)\n\nTo change the default port and address:\n\n# For a permanent change, set the preference:\nusing Preferences\nset_preferences!(\"LOCAL_SERVER\"=>\"http://127.0.0.1:10897/v1\")\n\n# Or if it's a temporary fix, just change the variable `LOCAL_SERVER`:\nconst PT = PromptingTools\nPT.LOCAL_SERVER = \"http://127.0.0.1:10897/v1\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.MaybeExtract","page":"PromptingTools.jl","title":"PromptingTools.MaybeExtract","text":"Extract a result from the provided data, if any, otherwise set the error and message fields.\n\nArguments\n\nerror::Bool: true if a result is found, false otherwise.\nmessage::String: Only present if no result is found, should be short and concise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.MistralOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.MistralOpenAISchema","text":"MistralOpenAISchema\n\nMistralOpenAISchema() allows user to call MistralAI API known for mistral and mixtral models.\n\nIt's a flavor of CustomOpenAISchema() with a url preset to https://api.mistral.ai.\n\nMost models have been registered, so you don't even have to specify the schema\n\nExample\n\nLet's call mistral-tiny model:\n\napi_key = \"...\" # can be set via ENV[\"MISTRAL_API_KEY\"] or via our preference system\nmsg = aigenerate(\"Say hi!\"; model=\"mistral_tiny\", api_key)\n\nSee ?PREFERENCES for more details on how to set your API key permanently.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.ModelSpec","page":"PromptingTools.jl","title":"PromptingTools.ModelSpec","text":"ModelSpec\n\nA struct that contains information about a model, such as its name, schema, cost per token, etc.\n\nFields\n\nname::String: The name of the model. This is the name that will be used to refer to the model in the ai* functions.\nschema::AbstractPromptSchema: The schema of the model. This is the schema that will be used to generate prompts for the model, eg, :OpenAISchema.\ncost_of_token_prompt::Float64: The cost of 1 token in the prompt for this model. This is used to calculate the cost of a prompt.    Note: It is often provided online as cost per 1000 tokens, so make sure to convert it correctly!\ncost_of_token_generation::Float64: The cost of 1 token generated by this model. This is used to calculate the cost of a generation.   Note: It is often provided online as cost per 1000 tokens, so make sure to convert it correctly!\ndescription::String: A description of the model. This is used to provide more information about the model when it is queried.\n\nExample\n\nspec = ModelSpec(\"gpt-3.5-turbo\",\n    OpenAISchema(),\n    0.0015,\n    0.002,\n    \"GPT-3.5 Turbo is a 175B parameter model and a common default on the OpenAI API.\")\n\n# register it\nPromptingTools.register_model!(spec)\n\nBut you can also register any model directly via keyword arguments:\n\nPromptingTools.register_model!(\n    name = \"gpt-3.5-turbo\",\n    schema = OpenAISchema(),\n    cost_of_token_prompt = 0.0015,\n    cost_of_token_generation = 0.002,\n    description = \"GPT-3.5 Turbo is a 175B parameter model and a common default on the OpenAI API.\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.NoSchema","page":"PromptingTools.jl","title":"PromptingTools.NoSchema","text":"Schema that keeps messages (<:AbstractMessage) and does not transform for any specific model. It used by the first pass of the prompt rendering system (see ?render).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.OllamaManagedSchema","page":"PromptingTools.jl","title":"PromptingTools.OllamaManagedSchema","text":"Ollama by default manages different models and their associated prompt schemas when you pass system_prompt and prompt fields to the API.\n\nWarning: It works only for 1 system message and 1 user message, so anything more than that has to be rejected.\n\nIf you need to pass more messagese / longer conversational history, you can use define the model-specific schema directly and pass your Ollama requests with raw=true,   which disables and templating and schema management by Ollama.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.OllamaSchema","page":"PromptingTools.jl","title":"PromptingTools.OllamaSchema","text":"OllamaSchema is the default schema for Olama models.\n\nIt uses the following conversation template:\n\n[Dict(role=\"system\",content=\"...\"),Dict(role=\"user\",content=\"...\"),Dict(role=\"assistant\",content=\"...\")]\n\nIt's very similar to OpenAISchema, but it appends images differently.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.OpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.OpenAISchema","text":"OpenAISchema is the default schema for OpenAI models.\n\nIt uses the following conversation template:\n\n[Dict(role=\"system\",content=\"...\"),Dict(role=\"user\",content=\"...\"),Dict(role=\"assistant\",content=\"...\")]\n\nIt's recommended to separate sections in your prompt with markdown headers (e.g. `##Answer\n\n`).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.TestEchoGoogleSchema","page":"PromptingTools.jl","title":"PromptingTools.TestEchoGoogleSchema","text":"Echoes the user's input back to them. Used for testing the implementation\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.TestEchoOllamaManagedSchema","page":"PromptingTools.jl","title":"PromptingTools.TestEchoOllamaManagedSchema","text":"Echoes the user's input back to them. Used for testing the implementation\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.TestEchoOllamaSchema","page":"PromptingTools.jl","title":"PromptingTools.TestEchoOllamaSchema","text":"Echoes the user's input back to them. Used for testing the implementation\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.TestEchoOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.TestEchoOpenAISchema","text":"Echoes the user's input back to them. Used for testing the implementation\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.TogetherOpenAISchema","page":"PromptingTools.jl","title":"PromptingTools.TogetherOpenAISchema","text":"TogetherOpenAISchema\n\nSchema to call the Together.ai API.\n\nLinks:\n\nGet your API key\nAPI Reference\nAvailable models\n\nRequires one environment variables to be set:\n\nTOGETHER_API_KEY: Your API key\n\n\n\n\n\n","category":"type"},{"location":"reference/#PromptingTools.UserMessageWithImages-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.UserMessageWithImages","text":"Construct UserMessageWithImages with 1 or more images. Images can be either URLs or local paths.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.X123","page":"PromptingTools.jl","title":"PromptingTools.X123","text":"With docstring\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenAI.create_chat-Tuple{PromptingTools.CustomOpenAISchema, AbstractString, AbstractString, Any}","page":"PromptingTools.jl","title":"OpenAI.create_chat","text":"OpenAI.create_chat(schema::CustomOpenAISchema,\n\napi_key::AbstractString,   model::AbstractString,   conversation;   url::String=\"http://localhost:8080\",   kwargs...)\n\nDispatch to the OpenAI.create_chat function, for any OpenAI-compatible API. \n\nIt expects url keyword argument. Provide it to the aigenerate function via api_kwargs=(; url=\"my-url\")\n\nIt will forward your query to the \"chat/completions\" endpoint of the base URL that you provided (=url).\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenAI.create_chat-Tuple{PromptingTools.LocalServerOpenAISchema, AbstractString, AbstractString, Any}","page":"PromptingTools.jl","title":"OpenAI.create_chat","text":"OpenAI.create_chat(schema::LocalServerOpenAISchema,\n    api_key::AbstractString,\n    model::AbstractString,\n    conversation;\n    url::String = \"http://localhost:8080\",\n    kwargs...)\n\nDispatch to the OpenAI.createchat function, but with the LocalServer API parameters, ie, defaults to url specified by the `LOCALSERVERpreference. See?PREFERENCES`\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenAI.create_chat-Tuple{PromptingTools.MistralOpenAISchema, AbstractString, AbstractString, Any}","page":"PromptingTools.jl","title":"OpenAI.create_chat","text":"OpenAI.create_chat(schema::MistralOpenAISchema,\n\napi_key::AbstractString,   model::AbstractString,   conversation;   url::String=\"https://api.mistral.ai/v1\",   kwargs...)\n\nDispatch to the OpenAI.create_chat function, but with the MistralAI API parameters. \n\nIt tries to access the MISTRALAI_API_KEY ENV variable, but you can also provide it via the api_key keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiclassify-Union{Tuple{T}, Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}} where T<:Union{AbstractString, Tuple{var\"#s104\", var\"#s103\"} where {var\"#s104\"<:AbstractString, var\"#s103\"<:AbstractString}}","page":"PromptingTools.jl","title":"PromptingTools.aiclassify","text":"aiclassify(prompt_schema::AbstractOpenAISchema, prompt::ALLOWED_PROMPT_TYPE;\n    choices::AbstractVector{T} = [\"true\", \"false\", \"unknown\"],\n    api_kwargs::NamedTuple = NamedTuple(),\n    kwargs...) where {T <: Union{AbstractString, Tuple{<:AbstractString, <:AbstractString}}}\n\nClassifies the given prompt/statement into an arbitrary list of choices, which must be only the choices (vector of strings) or choices and descriptions are provided (vector of tuples, ie, (\"choice\",\"description\")).\n\nIt's quick and easy option for \"routing\" and similar use cases, as it exploits the logit bias trick and outputs only 1 token. classify into an arbitrary list of categories (including with descriptions). It's quick and easy option for \"routing\" and similar use cases, as it exploits the logit bias trick, so it outputs only 1 token.\n\n!!! Note: The prompt/AITemplate must have a placeholder choices (ie, {{choices}}) that will be replaced with the encoded choices\n\nChoices are rewritten into an enumerated list and mapped to a few known OpenAI tokens (maximum of 20 choices supported). Mapping of token IDs for GPT3.5/4 are saved in variable OPENAI_TOKEN_IDS.\n\nIt uses Logit bias trick and limits the output to 1 token to force the model to output only true/false/unknown. Credit for the idea goes to AAAzzam.\n\nArguments\n\nprompt_schema::AbstractOpenAISchema: The schema for the prompt.\nprompt: The prompt/statement to classify if it's a String. If it's a Symbol, it is expanded as a template via render(schema,template). Eg, templates :JudgeIsItTrue or :InputClassifier\nchoices::AbstractVector{T}: The choices to be classified into. It can be a vector of strings or a vector of tuples, where the first element is the choice and the second is the description.\n\nExample\n\nGiven a user input, pick one of the two provided categories:\n\nchoices = [\"animal\", \"plant\"]\ninput = \"Palm tree\"\naiclassify(:InputClassifier; choices, input)\n\nChoices with descriptions provided as tuples:\n\nchoices = [(\"A\", \"any animal or creature\"), (\"P\", \"for any plant or tree\"), (\"O\", \"for everything else\")]\n\n# try the below inputs:\ninput = \"spider\" # -> returns \"A\" for any animal or creature\ninput = \"daphodil\" # -> returns \"P\" for any plant or tree\ninput = \"castle\" # -> returns \"O\" for everything else\naiclassify(:InputClassifier; choices, input)\n\nYou can still use a simple true/false classification:\n\naiclassify(\"Is two plus two four?\") # true\naiclassify(\"Is two plus three a vegetable on Mars?\") # false\n\naiclassify returns only true/false/unknown. It's easy to get the proper Bool output type out with tryparse, eg,\n\ntryparse(Bool, aiclassify(\"Is two plus two four?\")) isa Bool # true\n\nOutput of type Nothing marks that the model couldn't classify the statement as true/false.\n\nIdeally, we would like to re-use some helpful system prompt to get more accurate responses. For this reason we have templates, eg, :JudgeIsItTrue. By specifying the template, we can provide our statement as the expected variable (it in this case) See that the model now correctly classifies the statement as \"unknown\".\n\naiclassify(:JudgeIsItTrue; it = \"Is two plus three a vegetable on Mars?\") # unknown\n\nFor better results, use higher quality models like gpt4, eg, \n\naiclassify(:JudgeIsItTrue;\n    it = \"If I had two apples and I got three more, I have five apples now.\",\n    model = \"gpt4\") # true\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiembed-Union{Tuple{F}, Tuple{PromptingTools.AbstractOllamaManagedSchema, AbstractString}, Tuple{PromptingTools.AbstractOllamaManagedSchema, AbstractString, F}} where F<:Function","page":"PromptingTools.jl","title":"PromptingTools.aiembed","text":"aiembed(prompt_schema::AbstractOllamaManagedSchema,\n        doc_or_docs::Union{AbstractString, AbstractVector{<:AbstractString}},\n        postprocess::F = identity;\n        verbose::Bool = true,\n        api_key::String = \"\",\n        model::String = MODEL_EMBEDDING,\n        http_kwargs::NamedTuple = (retry_non_idempotent = true,\n                                   retries = 5,\n                                   readtimeout = 120),\n        api_kwargs::NamedTuple = NamedTuple(),\n        kwargs...) where {F <: Function}\n\nThe aiembed function generates embeddings for the given input using a specified model and returns a message object containing the embeddings, status, token count, and elapsed time.\n\nArguments\n\nprompt_schema::AbstractOllamaManagedSchema: The schema for the prompt.\ndoc_or_docs::Union{AbstractString, AbstractVector{<:AbstractString}}: The document or list of documents to generate embeddings for. The list of documents is processed sequentially,  so users should consider implementing an async version with with Threads.@spawn\npostprocess::F: The post-processing function to apply to each embedding. Defaults to the identity function, but could be LinearAlgebra.normalize.\nverbose::Bool: A flag indicating whether to print verbose information. Defaults to true.\napi_key::String: The API key to use for the OpenAI API. Defaults to \"\".\nmodel::String: The model to use for generating embeddings. Defaults to MODEL_EMBEDDING.\nhttp_kwargs::NamedTuple: Additional keyword arguments for the HTTP request. Defaults to empty NamedTuple.\napi_kwargs::NamedTuple: Additional keyword arguments for the Ollama API. Defaults to an empty NamedTuple.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nmsg: A DataMessage object containing the embeddings, status, token count, and elapsed time.\n\nNote: Ollama API currently does not return the token count, so it's set to (0,0)\n\nExample\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\n\nmsg = aiembed(schema, \"Hello World\"; model=\"openhermes2.5-mistral\")\nmsg.content # 4096-element JSON3.Array{Float64...\n\nWe can embed multiple strings at once and they will be hcat into a matrix   (ie, each column corresponds to one string)\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\n\nmsg = aiembed(schema, [\"Hello World\", \"How are you?\"]; model=\"openhermes2.5-mistral\")\nmsg.content # 4096×2 Matrix{Float64}:\n\nIf you plan to calculate the cosine distance between embeddings, you can normalize them first:\n\nconst PT = PromptingTools\nusing LinearAlgebra\nschema = PT.OllamaManagedSchema()\n\nmsg = aiembed(schema, [\"embed me\", \"and me too\"], LinearAlgebra.normalize; model=\"openhermes2.5-mistral\")\n\n# calculate cosine distance between the two normalized embeddings as a simple dot product\nmsg.content' * msg.content[:, 1] # [1.0, 0.34]\n\nSimilarly, you can use the postprocess argument to materialize the data from JSON3.Object by using postprocess = copy\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\n\nmsg = aiembed(schema, \"Hello World\", copy; model=\"openhermes2.5-mistral\")\nmsg.content # 4096-element Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiembed-Union{Tuple{F}, Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, AbstractVector{<:AbstractString}}}, Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, AbstractVector{<:AbstractString}}, F}} where F<:Function","page":"PromptingTools.jl","title":"PromptingTools.aiembed","text":"aiembed(prompt_schema::AbstractOpenAISchema,\n        doc_or_docs::Union{AbstractString, AbstractVector{<:AbstractString}},\n        postprocess::F = identity;\n        verbose::Bool = true,\n        api_key::String = OPENAI_API_KEY,\n        model::String = MODEL_EMBEDDING, \n        http_kwargs::NamedTuple = (retry_non_idempotent = true,\n                                   retries = 5,\n                                   readtimeout = 120),\n        api_kwargs::NamedTuple = NamedTuple(),\n        kwargs...) where {F <: Function}\n\nThe aiembed function generates embeddings for the given input using a specified model and returns a message object containing the embeddings, status, token count, and elapsed time.\n\nArguments\n\nprompt_schema::AbstractOpenAISchema: The schema for the prompt.\ndoc_or_docs::Union{AbstractString, AbstractVector{<:AbstractString}}: The document or list of documents to generate embeddings for.\npostprocess::F: The post-processing function to apply to each embedding. Defaults to the identity function.\nverbose::Bool: A flag indicating whether to print verbose information. Defaults to true.\napi_key::String: The API key to use for the OpenAI API. Defaults to OPENAI_API_KEY.\nmodel::String: The model to use for generating embeddings. Defaults to MODEL_EMBEDDING.\nhttp_kwargs::NamedTuple: Additional keyword arguments for the HTTP request. Defaults to (retry_non_idempotent = true, retries = 5, readtimeout = 120).\napi_kwargs::NamedTuple: Additional keyword arguments for the OpenAI API. Defaults to an empty NamedTuple.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nmsg: A DataMessage object containing the embeddings, status, token count, and elapsed time. Use msg.content to access the embeddings.\n\nExample\n\nmsg = aiembed(\"Hello World\")\nmsg.content # 1536-element JSON3.Array{Float64...\n\nWe can embed multiple strings at once and they will be hcat into a matrix   (ie, each column corresponds to one string)\n\nmsg = aiembed([\"Hello World\", \"How are you?\"])\nmsg.content # 1536×2 Matrix{Float64}:\n\nIf you plan to calculate the cosine distance between embeddings, you can normalize them first:\n\nusing LinearAlgebra\nmsg = aiembed([\"embed me\", \"and me too\"], LinearAlgebra.normalize)\n\n# calculate cosine distance between the two normalized embeddings as a simple dot product\nmsg.content' * msg.content[:, 1] # [1.0, 0.787]\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiextract-Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aiextract","text":"aiextract(prompt_schema::AbstractOpenAISchema, prompt::ALLOWED_PROMPT_TYPE;\n    return_type::Type,\n    verbose::Bool = true,\n    api_key::String = OPENAI_API_KEY,\n    model::String = MODEL_CHAT,\n    return_all::Bool = false, dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    http_kwargs::NamedTuple = (retry_non_idempotent = true,\n        retries = 5,\n        readtimeout = 120), api_kwargs::NamedTuple = (;\n        tool_choice = \"exact\"),\n    kwargs...)\n\nExtract required information (defined by a struct return_type) from the provided prompt by leveraging OpenAI function calling mode.\n\nThis is a perfect solution for extracting structured information from text (eg, extract organization names in news articles, etc.)\n\nIt's effectively a light wrapper around aigenerate call, which requires additional keyword argument return_type to be provided  and will enforce the model outputs to adhere to it.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nreturn_type: A struct TYPE representing the the information we want to extract. Do not provide a struct instance, only the type. If the struct has a docstring, it will be provided to the model as well. It's used to enforce structured model outputs or provide more information.\nverbose: A boolean indicating whether to print additional information.\napi_key: A string representing the API key for accessing the OpenAI API.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nhttp_kwargs: A named tuple of HTTP keyword arguments.\napi_kwargs: A named tuple of API keyword arguments. \ntool_choice: A string representing the tool choice to use for the API call. Usually, one of \"auto\",\"any\",\"exact\".  Defaults to \"exact\", which is a made-up value to enforce the OpenAI requirements if we want one exact function. Providers like Mistral, Together, etc. use \"any\" instead.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nIf return_all=false (default):\n\nmsg: An DataMessage object representing the extracted data, including the content, status, tokens, and elapsed time.  Use msg.content to access the extracted data.\n\nIf return_all=true:\n\nconversation: A vector of AbstractMessage objects representing the full conversation history, including the response from the AI model (DataMessage).\n\nSee also: function_call_signature, MaybeExtract, ItemsExtract, aigenerate\n\nExample\n\nDo you want to extract some specific measurements from a text like age, weight and height? You need to define the information you need as a struct (return_type):\n\n\"Person's age, height, and weight.\"\nstruct MyMeasurement\n    age::Int # required\n    height::Union{Int,Nothing} # optional\n    weight::Union{Nothing,Float64} # optional\nend\nmsg = aiextract(\"James is 30, weighs 80kg. He's 180cm tall.\"; return_type=MyMeasurement)\n# PromptingTools.DataMessage(MyMeasurement)\nmsg.content\n# MyMeasurement(30, 180, 80.0)\n\nThe fields that allow Nothing are marked as optional in the schema:\n\nmsg = aiextract(\"James is 30.\"; return_type=MyMeasurement)\n# MyMeasurement(30, nothing, nothing)\n\nIf there are multiple items you want to extract, define a wrapper struct to get a Vector of MyMeasurement:\n\nstruct MyMeasurementWrapper\n    measurements::Vector{MyMeasurement}\nend\n\nmsg = aiextract(\"James is 30, weighs 80kg. He's 180cm tall. Then Jack is 19 but really tall - over 190!\"; return_type=ManyMeasurements)\n\nmsg.content.measurements\n# 2-element Vector{MyMeasurement}:\n#  MyMeasurement(30, 180, 80.0)\n#  MyMeasurement(19, 190, nothing)\n\nOr you can use the convenience wrapper ItemsExtract to extract multiple measurements (zero, one or more):\n\nusing PromptingTools: ItemsExtract\n\nreturn_type = ItemsExtract{MyMeasurement}\nmsg = aiextract(\"James is 30, weighs 80kg. He's 180cm tall. Then Jack is 19 but really tall - over 190!\"; return_type)\n\nmsg.content.items # see the extracted items\n\nOr if you want your extraction to fail gracefully when data isn't found, use MaybeExtract{T} wrapper  (this trick is inspired by the Instructor package!):\n\nusing PromptingTools: MaybeExtract\n\ntype = MaybeExtract{MyMeasurement}\n# Effectively the same as:\n# struct MaybeExtract{T}\n#     result::Union{T, Nothing} // The result of the extraction\n#     error::Bool // true if a result is found, false otherwise\n#     message::Union{Nothing, String} // Only present if no result is found, should be short and concise\n# end\n\n# If LLM extraction fails, it will return a Dict with `error` and `message` fields instead of the result!\nmsg = aiextract(\"Extract measurements from the text: I am giraffe\", type)\nmsg.content\n# MaybeExtract{MyMeasurement}(nothing, true, \"I'm sorry, but I can only assist with human measurements.\")\n\nThat way, you can handle the error gracefully and get a reason why extraction failed (in msg.content.message).\n\nNote that the error message refers to a giraffe not being a human,   because in our MyMeasurement docstring, we said that it's for people!\n\nSome non-OpenAI providers require a different specification of the \"tool choice\" than OpenAI.  For example, to use Mistral models (\"mistrall\" for mistral large), do:\n\n\"Some fruit\"\nstruct Fruit\n    name::String\nend\naiextract(\"I ate an apple\",return_type=Fruit,api_kwargs=(;tool_choice=\"any\"),model=\"mistrall\")\n# Notice two differences: 1) struct MUST have a docstring, 2) tool_choice is set explicitly set to \"any\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aigenerate-Tuple{PromptingTools.AbstractGoogleSchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aigenerate","text":"aigenerate(prompt_schema::AbstractGoogleSchema, prompt::ALLOWED_PROMPT_TYPE;\n    verbose::Bool = true,\n    api_key::String = GOOGLE_API_KEY,\n    model::String = \"gemini-pro\", return_all::Bool = false, dry_run::Bool = false,\n    http_kwargs::NamedTuple = (retry_non_idempotent = true,\n        retries = 5,\n        readtimeout = 120), api_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nGenerate an AI response based on a given prompt using the Google Gemini API. Get the API key here.\n\nNote: \n\nThere is no \"cost\" reported as of February 2024, as all access seems to be free-of-charge. See the details here.\ntokens in the returned AIMessage are actually characters, not tokens. We use a conservative estimate as they are not provided by the API yet.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nverbose: A boolean indicating whether to print additional information.\napi_key: A string representing the API key for accessing the OpenAI API.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES. Defaults to \nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nhttp_kwargs: A named tuple of HTTP keyword arguments.\napi_kwargs: A named tuple of API keyword arguments.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nIf return_all=false (default):\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nIf return_all=true:\n\nconversation: A vector of AbstractMessage objects representing the conversation history, including the response from the AI model (AIMessage).\n\nSee also: ai_str, aai_str, aiembed, aiclassify, aiextract, aiscan, aitemplates\n\nExample\n\nSimple hello world to test the API:\n\nresult = aigenerate(\"Say Hi!\"; model=\"gemini-pro\")\n# AIMessage(\"Hi there! 👋 I'm here to help you with any questions or tasks you may have. Just let me know what you need, and I'll do my best to assist you.\")\n\nresult is an AIMessage object. Access the generated string via content property:\n\ntypeof(result) # AIMessage{SubString{String}}\npropertynames(result) # (:content, :status, :tokens, :elapsed\nresult.content # \"Hi there! ...\n\n___ You can use string interpolation and alias \"gemini\":\n\na = 1\nmsg=aigenerate(\"What is `$a+$a`?\"; model=\"gemini\")\nmsg.content # \"1+1 is 2.\"\n\n___ You can provide the whole conversation or more intricate prompts as a Vector{AbstractMessage}:\n\nconst PT = PromptingTools\n\nconversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\nmsg=aigenerate(conversation; model=\"gemini\")\n# AIMessage(\"Young Padawan, you have stumbled into a dangerous path.... <continues>\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aigenerate-Tuple{PromptingTools.AbstractOllamaManagedSchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aigenerate","text":"aigenerate(prompt_schema::AbstractOllamaManagedSchema, prompt::ALLOWED_PROMPT_TYPE; verbose::Bool = true,\n    api_key::String = \"\", model::String = MODEL_CHAT,\n    return_all::Bool = false, dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    http_kwargs::NamedTuple = NamedTuple(), api_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nGenerate an AI response based on a given prompt using the OpenAI API.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema not AbstractManagedSchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nverbose: A boolean indicating whether to print additional information.\napi_key: Provided for interface consistency. Not needed for locally hosted Ollama.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation::AbstractVector{<:AbstractMessage}=[]: Not allowed for this schema. Provided only for compatibility.\nhttp_kwargs::NamedTuple: Additional keyword arguments for the HTTP request. Defaults to empty NamedTuple.\napi_kwargs::NamedTuple: Additional keyword arguments for the Ollama API. Defaults to an empty NamedTuple.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nSee also: ai_str, aai_str, aiembed\n\nExample\n\nSimple hello world to test the API:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema() # We need to explicit if we want Ollama, OpenAISchema is the default\n\nmsg = aigenerate(schema, \"Say hi!\"; model=\"openhermes2.5-mistral\")\n# [ Info: Tokens: 69 in 0.9 seconds\n# AIMessage(\"Hello! How can I assist you today?\")\n\nmsg is an AIMessage object. Access the generated string via content property:\n\ntypeof(msg) # AIMessage{SubString{String}}\npropertynames(msg) # (:content, :status, :tokens, :elapsed\nmsg.content # \"Hello! How can I assist you today?\"\n\nNote: We need to be explicit about the schema we want to use. If we don't, it will default to OpenAISchema (=PT.DEFAULT_SCHEMA) ___ You can use string interpolation:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\na = 1\nmsg=aigenerate(schema, \"What is `$a+$a`?\"; model=\"openhermes2.5-mistral\")\nmsg.content # \"The result of `1+1` is `2`.\"\n\n___ You can provide the whole conversation or more intricate prompts as a Vector{AbstractMessage}:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\n\nconversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\n\nmsg = aigenerate(schema, conversation; model=\"openhermes2.5-mistral\")\n# [ Info: Tokens: 111 in 2.1 seconds\n# AIMessage(\"Strong the attachment is, it leads to suffering it may. Focus on the force within you must, ...<continues>\")\n\nNote: Managed Ollama currently supports at most 1 User Message and 1 System Message given the API limitations. If you want more, you need to use the ChatMLSchema.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aigenerate-Tuple{PromptingTools.AbstractOllamaSchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aigenerate","text":"aigenerate(prompt_schema::AbstractOllamaManagedSchema, prompt::ALLOWED_PROMPT_TYPE; verbose::Bool = true,\n    api_key::String = \"\", model::String = MODEL_CHAT,\n    return_all::Bool = false, dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    http_kwargs::NamedTuple = NamedTuple(), api_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nGenerate an AI response based on a given prompt using the OpenAI API.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema not AbstractManagedSchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nverbose: A boolean indicating whether to print additional information.\napi_key: Provided for interface consistency. Not needed for locally hosted Ollama.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation::AbstractVector{<:AbstractMessage}=[]: Not allowed for this schema. Provided only for compatibility.\nhttp_kwargs::NamedTuple: Additional keyword arguments for the HTTP request. Defaults to empty NamedTuple.\napi_kwargs::NamedTuple: Additional keyword arguments for the Ollama API. Defaults to an empty NamedTuple.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nSee also: ai_str, aai_str, aiembed\n\nExample\n\nSimple hello world to test the API:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema() # We need to explicit if we want Ollama, OpenAISchema is the default\n\nmsg = aigenerate(schema, \"Say hi!\"; model=\"openhermes2.5-mistral\")\n# [ Info: Tokens: 69 in 0.9 seconds\n# AIMessage(\"Hello! How can I assist you today?\")\n\nmsg is an AIMessage object. Access the generated string via content property:\n\ntypeof(msg) # AIMessage{SubString{String}}\npropertynames(msg) # (:content, :status, :tokens, :elapsed\nmsg.content # \"Hello! How can I assist you today?\"\n\nNote: We need to be explicit about the schema we want to use. If we don't, it will default to OpenAISchema (=PT.DEFAULT_SCHEMA) ___ You can use string interpolation:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\na = 1\nmsg=aigenerate(schema, \"What is `$a+$a`?\"; model=\"openhermes2.5-mistral\")\nmsg.content # \"The result of `1+1` is `2`.\"\n\n___ You can provide the whole conversation or more intricate prompts as a Vector{AbstractMessage}:\n\nconst PT = PromptingTools\nschema = PT.OllamaManagedSchema()\n\nconversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\n\nmsg = aigenerate(schema, conversation; model=\"openhermes2.5-mistral\")\n# [ Info: Tokens: 111 in 2.1 seconds\n# AIMessage(\"Strong the attachment is, it leads to suffering it may. Focus on the force within you must, ...<continues>\")\n\nNote: Managed Ollama currently supports at most 1 User Message and 1 System Message given the API limitations. If you want more, you need to use the ChatMLSchema.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aigenerate-Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aigenerate","text":"aigenerate(prompt_schema::AbstractOpenAISchema, prompt::ALLOWED_PROMPT_TYPE;\n    verbose::Bool = true,\n    api_key::String = OPENAI_API_KEY,\n    model::String = MODEL_CHAT, return_all::Bool = false, dry_run::Bool = false,\n    http_kwargs::NamedTuple = (retry_non_idempotent = true,\n        retries = 5,\n        readtimeout = 120), api_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nGenerate an AI response based on a given prompt using the OpenAI API.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nverbose: A boolean indicating whether to print additional information.\napi_key: A string representing the API key for accessing the OpenAI API.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nhttp_kwargs: A named tuple of HTTP keyword arguments.\napi_kwargs: A named tuple of API keyword arguments. Useful parameters include:\ntemperature: A float representing the temperature for sampling (ie, the amount of \"creativity\"). Often defaults to 0.7.\nlogprobs: A boolean indicating whether to return log probabilities for each token. Defaults to false.\nn: An integer representing the number of completions to generate at once (if supported).\nstop: A vector of strings representing the stop conditions for the conversation. Defaults to an empty vector.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nIf return_all=false (default):\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nIf return_all=true:\n\nconversation: A vector of AbstractMessage objects representing the conversation history, including the response from the AI model (AIMessage).\n\nSee also: ai_str, aai_str, aiembed, aiclassify, aiextract, aiscan, aitemplates\n\nExample\n\nSimple hello world to test the API:\n\nresult = aigenerate(\"Say Hi!\")\n# [ Info: Tokens: 29 @ Cost: $0.0 in 1.0 seconds\n# AIMessage(\"Hello! How can I assist you today?\")\n\nresult is an AIMessage object. Access the generated string via content property:\n\ntypeof(result) # AIMessage{SubString{String}}\npropertynames(result) # (:content, :status, :tokens, :elapsed\nresult.content # \"Hello! How can I assist you today?\"\n\n___ You can use string interpolation:\n\na = 1\nmsg=aigenerate(\"What is `$a+$a`?\")\nmsg.content # \"The sum of `1+1` is `2`.\"\n\n___ You can provide the whole conversation or more intricate prompts as a Vector{AbstractMessage}:\n\nconst PT = PromptingTools\n\nconversation = [\n    PT.SystemMessage(\"You're master Yoda from Star Wars trying to help the user become a Yedi.\"),\n    PT.UserMessage(\"I have feelings for my iPhone. What should I do?\")]\nmsg=aigenerate(conversation)\n# AIMessage(\"Ah, strong feelings you have for your iPhone. A Jedi's path, this is not... <continues>\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiscan-Tuple{PromptingTools.AbstractOllamaSchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aiscan","text":"aiscan([prompt_schema::AbstractOllamaSchema,] prompt::ALLOWED_PROMPT_TYPE; \nimage_url::Union{Nothing, AbstractString, Vector{<:AbstractString}} = nothing,\nimage_path::Union{Nothing, AbstractString, Vector{<:AbstractString}} = nothing,\nattach_to_latest::Bool = true,\nverbose::Bool = true, api_key::String = OPENAI_API_KEY,\n    model::String = MODEL_CHAT,\n    return_all::Bool = false, dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    http_kwargs::NamedTuple = (;\n        retry_non_idempotent = true,\n        retries = 5,\n        readtimeout = 120), \n    api_kwargs::NamedTuple = = (; max_tokens = 2500),\n    kwargs...)\n\nScans the provided image (image_url or image_path) with the goal provided in the prompt.\n\nCan be used for many multi-modal tasks, such as: OCR (transcribe text in the image), image captioning, image classification, etc.\n\nIt's effectively a light wrapper around aigenerate call, which uses additional keyword arguments image_url, image_path, image_detail to be provided.   At least one image source (url or path) must be provided.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nimage_url: A string or vector of strings representing the URL(s) of the image(s) to scan.\nimage_path: A string or vector of strings representing the path(s) of the image(s) to scan.\nimage_detail: A string representing the level of detail to include for images. Can be \"auto\", \"high\", or \"low\". See OpenAI Vision Guide for more details.\nattach_to_latest: A boolean how to handle if a conversation with multiple UserMessage is provided. When true, the images are attached to the latest UserMessage.\nverbose: A boolean indicating whether to print additional information.\napi_key: A string representing the API key for accessing the OpenAI API.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nhttp_kwargs: A named tuple of HTTP keyword arguments.\napi_kwargs: A named tuple of API keyword arguments.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nIf return_all=false (default):\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nIf return_all=true:\n\nconversation: A vector of AbstractMessage objects representing the full conversation history, including the response from the AI model (AIMessage).\n\nSee also: ai_str, aai_str, aigenerate, aiembed, aiclassify, aiextract, aitemplates\n\nNotes\n\nAll examples below use model \"gpt4v\", which is an alias for model ID \"gpt-4-vision-preview\"\nmax_tokens in the api_kwargs is preset to 2500, otherwise OpenAI enforces a default of only a few hundred tokens (~300). If your output is truncated, increase this value\n\nExample\n\nDescribe the provided image:\n\nmsg = aiscan(\"Describe the image\"; image_path=\"julia.png\", model=\"bakllava\")\n# [ Info: Tokens: 1141 @ Cost: $0.0117 in 2.2 seconds\n# AIMessage(\"The image shows a logo consisting of the word \"julia\" written in lowercase\")\n\nYou can provide multiple images at once as a vector and ask for \"low\" level of detail (cheaper):\n\nmsg = aiscan(\"Describe the image\"; image_path=[\"julia.png\",\"python.png\"] model=\"bakllava\")\n\nYou can use this function as a nice and quick OCR (transcribe text in the image) with a template :OCRTask.  Let's transcribe some SQL code from a screenshot (no more re-typing!):\n\nusing Downloads\n# Screenshot of some SQL code -- we cannot use image_url directly, so we need to download it first\nimage_url = \"https://www.sqlservercentral.com/wp-content/uploads/legacy/8755f69180b7ac7ee76a69ae68ec36872a116ad4/24622.png\"\nimage_path = Downloads.download(image_url)\nmsg = aiscan(:OCRTask; image_path, model=\"bakllava\", task=\"Transcribe the SQL code in the image.\", api_kwargs=(; max_tokens=2500))\n\n# AIMessage(\"```sql\n# update Orders <continue>\n\n# You can add syntax highlighting of the outputs via Markdown\nusing Markdown\nmsg.content |> Markdown.parse\n\nLocal models cannot handle image URLs directly (image_url), so you need to download the image first and provide it as image_path:\n\nusing Downloads\nimage_path = Downloads.download(image_url)\n\nNotice that we set max_tokens = 2500. If your outputs seem truncated, it might be because the default maximum tokens on the server is set too low!\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aiscan-Tuple{PromptingTools.AbstractOpenAISchema, Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.aiscan","text":"aiscan([prompt_schema::AbstractOpenAISchema,] prompt::ALLOWED_PROMPT_TYPE; \nimage_url::Union{Nothing, AbstractString, Vector{<:AbstractString}} = nothing,\nimage_path::Union{Nothing, AbstractString, Vector{<:AbstractString}} = nothing,\nimage_detail::AbstractString = \"auto\",\nattach_to_latest::Bool = true,\nverbose::Bool = true, api_key::String = OPENAI_API_KEY,\n    model::String = MODEL_CHAT,\n    return_all::Bool = false, dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    http_kwargs::NamedTuple = (;\n        retry_non_idempotent = true,\n        retries = 5,\n        readtimeout = 120), \n    api_kwargs::NamedTuple = = (; max_tokens = 2500),\n    kwargs...)\n\nScans the provided image (image_url or image_path) with the goal provided in the prompt.\n\nCan be used for many multi-modal tasks, such as: OCR (transcribe text in the image), image captioning, image classification, etc.\n\nIt's effectively a light wrapper around aigenerate call, which uses additional keyword arguments image_url, image_path, image_detail to be provided.   At least one image source (url or path) must be provided.\n\nArguments\n\nprompt_schema: An optional object to specify which prompt template should be applied (Default to PROMPT_SCHEMA = OpenAISchema)\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage or an AITemplate\nimage_url: A string or vector of strings representing the URL(s) of the image(s) to scan.\nimage_path: A string or vector of strings representing the path(s) of the image(s) to scan.\nimage_detail: A string representing the level of detail to include for images. Can be \"auto\", \"high\", or \"low\". See OpenAI Vision Guide for more details.\nattach_to_latest: A boolean how to handle if a conversation with multiple UserMessage is provided. When true, the images are attached to the latest UserMessage.\nverbose: A boolean indicating whether to print additional information.\napi_key: A string representing the API key for accessing the OpenAI API.\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, skips sending the messages to the model (for debugging, often used with return_all=true).\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nhttp_kwargs: A named tuple of HTTP keyword arguments.\napi_kwargs: A named tuple of API keyword arguments.\nkwargs: Prompt variables to be used to fill the prompt/template\n\nReturns\n\nIf return_all=false (default):\n\nmsg: An AIMessage object representing the generated AI message, including the content, status, tokens, and elapsed time.\n\nUse msg.content to access the extracted string.\n\nIf return_all=true:\n\nconversation: A vector of AbstractMessage objects representing the full conversation history, including the response from the AI model (AIMessage).\n\nSee also: ai_str, aai_str, aigenerate, aiembed, aiclassify, aiextract, aitemplates\n\nNotes\n\nAll examples below use model \"gpt4v\", which is an alias for model ID \"gpt-4-vision-preview\"\nmax_tokens in the api_kwargs is preset to 2500, otherwise OpenAI enforces a default of only a few hundred tokens (~300). If your output is truncated, increase this value\n\nExample\n\nDescribe the provided image:\n\nmsg = aiscan(\"Describe the image\"; image_path=\"julia.png\", model=\"gpt4v\")\n# [ Info: Tokens: 1141 @ Cost: $0.0117 in 2.2 seconds\n# AIMessage(\"The image shows a logo consisting of the word \"julia\" written in lowercase\")\n\nYou can provide multiple images at once as a vector and ask for \"low\" level of detail (cheaper):\n\nmsg = aiscan(\"Describe the image\"; image_path=[\"julia.png\",\"python.png\"], image_detail=\"low\", model=\"gpt4v\")\n\nYou can use this function as a nice and quick OCR (transcribe text in the image) with a template :OCRTask.  Let's transcribe some SQL code from a screenshot (no more re-typing!):\n\n# Screenshot of some SQL code\nimage_url = \"https://www.sqlservercentral.com/wp-content/uploads/legacy/8755f69180b7ac7ee76a69ae68ec36872a116ad4/24622.png\"\nmsg = aiscan(:OCRTask; image_url, model=\"gpt4v\", task=\"Transcribe the SQL code in the image.\", api_kwargs=(; max_tokens=2500))\n\n# [ Info: Tokens: 362 @ Cost: $0.0045 in 2.5 seconds\n# AIMessage(\"```sql\n# update Orders <continue>\n\n# You can add syntax highlighting of the outputs via Markdown\nusing Markdown\nmsg.content |> Markdown.parse\n\nNotice that we enforce max_tokens = 2500. That's because OpenAI seems to default to ~300 tokens, which provides incomplete outputs. Hence, we set this value to 2500 as a default. If you still get truncated outputs, increase this value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aitemplates","page":"PromptingTools.jl","title":"PromptingTools.aitemplates","text":"aitemplates\n\nFind easily the most suitable templates for your use case.\n\nYou can search by:\n\nquery::Symbol which looks look only for partial matches in the template name\nquery::AbstractString which looks for partial matches in the template name or description\nquery::Regex which looks for matches in the template name, description or any of the message previews\n\nKeyword Arguments\n\nlimit::Int limits the number of returned templates (Defaults to 10)\n\nExamples\n\nFind available templates with aitemplates:\n\ntmps = aitemplates(\"JuliaExpertAsk\")\n# Will surface one specific template\n# 1-element Vector{AITemplateMetadata}:\n# PromptingTools.AITemplateMetadata\n#   name: Symbol JuliaExpertAsk\n#   description: String \"For asking questions about Julia language. Placeholders: `ask`\"\n#   version: String \"1\"\n#   wordcount: Int64 237\n#   variables: Array{Symbol}((1,))\n#   system_preview: String \"You are a world-class Julia language programmer with the knowledge of the latest syntax. Your commun\"\n#   user_preview: String \"# Question\n\n{{ask}}\"\n#   source: String \"\"\n\nThe above gives you a good idea of what the template is about, what placeholders are available, and how much it would cost to use it (=wordcount).\n\nSearch for all Julia-related templates:\n\ntmps = aitemplates(\"Julia\")\n# 2-element Vector{AITemplateMetadata}... -> more to come later!\n\nIf you are on VSCode, you can leverage nice tabular display with vscodedisplay:\n\nusing DataFrames\ntmps = aitemplates(\"Julia\") |> DataFrame |> vscodedisplay\n\nI have my selected template, how do I use it? Just use the \"name\" in aigenerate or aiclassify   like you see in the first example!\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.aitemplates-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.aitemplates","text":"Find the top-limit templates whose name or description fields partially match the query_key::String in TEMPLATE_METADATA.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aitemplates-Tuple{Regex}","page":"PromptingTools.jl","title":"PromptingTools.aitemplates","text":"Find the top-limit templates where provided query_key::Regex matches either of name, description or previews or User or System messages in TEMPLATE_METADATA.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.aitemplates-Tuple{Symbol}","page":"PromptingTools.jl","title":"PromptingTools.aitemplates","text":"Find the top-limit templates whose name::Symbol partially matches the query_name::Symbol in TEMPLATE_METADATA.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.auth_header-Tuple{Union{Nothing, AbstractString}}","page":"PromptingTools.jl","title":"PromptingTools.auth_header","text":"auth_header(api_key::Union{Nothing, AbstractString};\n    extra_headers::AbstractVector{Pair{String, String}} = Vector{Pair{String, String}}[],\n    kwargs...)\n\nCreates the authentication headers for any API request. Assumes that the communication is done in JSON format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.call_cost-Tuple{Int64, Int64, String}","page":"PromptingTools.jl","title":"PromptingTools.call_cost","text":"call_cost(prompt_tokens::Int, completion_tokens::Int, model::String;\n    cost_of_token_prompt::Number = get(MODEL_REGISTRY,\n        model,\n        (; cost_of_token_prompt = 0.0)).cost_of_token_prompt,\n    cost_of_token_generation::Number = get(MODEL_REGISTRY, model,\n        (; cost_of_token_generation = 0.0)).cost_of_token_generation)\n\ncall_cost(msg, model::String)\n\nCalculate the cost of a call based on the number of tokens in the message and the cost per token.\n\nArguments\n\nprompt_tokens::Int: The number of tokens used in the prompt.\ncompletion_tokens::Int: The number of tokens used in the completion.\nmodel::String: The name of the model to use for determining token costs. If the model is not found in MODEL_REGISTRY, default costs are used.\ncost_of_token_prompt::Number: The cost per prompt token. Defaults to the cost in MODEL_REGISTRY for the given model, or 0.0 if the model is not found.\ncost_of_token_generation::Number: The cost per generation token. Defaults to the cost in MODEL_REGISTRY for the given model, or 0.0 if the model is not found.\n\nReturns\n\nNumber: The total cost of the call.\n\nExamples\n\n# Assuming MODEL_REGISTRY is set up with appropriate costs\nMODEL_REGISTRY = Dict(\n    \"model1\" => (cost_of_token_prompt = 0.05, cost_of_token_generation = 0.10),\n    \"model2\" => (cost_of_token_prompt = 0.07, cost_of_token_generation = 0.02)\n)\n\ncost1 = call_cost(10, 20, \"model1\")\n\n# from message\nmsg1 = AIMessage(;tokens=[10, 20])  # 10 prompt tokens, 20 generation tokens\ncost1 = call_cost(msg1, \"model1\")\n# cost1 = 10 * 0.05 + 20 * 0.10 = 2.5\n\n# Using custom token costs\ncost2 = call_cost(10, 20, \"model3\"; cost_of_token_prompt = 0.08, cost_of_token_generation = 0.12)\n# cost2 = 10 * 0.08 + 20 * 0.12 = 3.2\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.decode_choices-Tuple{PromptingTools.OpenAISchema, AbstractVector{<:AbstractString}, AIMessage}","page":"PromptingTools.jl","title":"PromptingTools.decode_choices","text":"decode_choices(schema::OpenAISchema,\n    choices::AbstractVector{<:AbstractString},\n    msg::AIMessage; kwargs...)\n\nDecodes the underlying AIMessage against the original choices to lookup what the category name was.\n\nIf it fails, it will return msg.content == nothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.detect_base_main_overrides-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.detect_base_main_overrides","text":"detect_base_main_overrides(code_block::AbstractString)\n\nDetects if a given code block overrides any Base or Main methods. \n\nReturns a tuple of a boolean and a vector of the overriden methods.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.encode_choices-Tuple{PromptingTools.OpenAISchema, AbstractVector{<:AbstractString}}","page":"PromptingTools.jl","title":"PromptingTools.encode_choices","text":"encode_choices(schema::OpenAISchema, choices::AbstractVector{<:AbstractString}; kwargs...)\n\nencode_choices(schema::OpenAISchema, choices::AbstractVector{T};\nkwargs...) where {T <: Tuple{<:AbstractString, <:AbstractString}}\n\nEncode the choices into an enumerated list that can be interpolated into the prompt and creates the corresponding logit biases (to choose only from the selected tokens).\n\nOptionally, can be a vector tuples, where the first element is the choice and the second is the description.\n\nArguments\n\nschema::OpenAISchema: The OpenAISchema object.\nchoices::AbstractVector{<:Union{AbstractString,Tuple{<:AbstractString, <:AbstractString}}}: The choices to be encoded, represented as a vector of the choices directly, or tuples where each tuple contains a choice and its description.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nchoices_prompt::AbstractString: The encoded choices as a single string, separated by newlines.\nlogit_bias::Dict: The logit bias dictionary, where the keys are the token IDs and the values are the bias values.\ndecode_ids::AbstractVector{<:AbstractString}: The decoded IDs of the choices.\n\nExamples\n\nchoices_prompt, logit_bias, _ = PT.encode_choices(PT.OpenAISchema(), [\"true\", \"false\"])\nchoices_prompt # Output: \"true for \"true\"\nfalse for \"false\"\nlogit_bias # Output: Dict(837 => 100, 905 => 100)\n\nchoices_prompt, logit_bias, _ = PT.encode_choices(PT.OpenAISchema(), [\"animal\", \"plant\"])\nchoices_prompt # Output: \"1. \"animal\"\n2. \"plant\"\"\nlogit_bias # Output: Dict(16 => 100, 17 => 100)\n\nOr choices with descriptions:\n\nchoices_prompt, logit_bias, _ = PT.encode_choices(PT.OpenAISchema(), [(\"A\", \"any animal or creature\"), (\"P\", \"for any plant or tree\"), (\"O\", \"for everything else\")])\nchoices_prompt # Output: \"1. \"A\" for any animal or creature\n2. \"P\" for any plant or tree\n3. \"O\" for everything else\"\nlogit_bias # Output: Dict(16 => 100, 17 => 100, 18 => 100)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.eval!-Tuple{PromptingTools.AbstractCodeBlock}","page":"PromptingTools.jl","title":"PromptingTools.eval!","text":"eval!(cb::AbstractCodeBlock;\n    safe_eval::Bool = true,\n    capture_stdout::Bool = true,\n    prefix::AbstractString = \"\",\n    suffix::AbstractString = \"\")\n\nEvaluates a code block cb in-place. It runs automatically when AICode is instantiated with a String.\n\nCheck the outcome of evaluation with Base.isvalid(cb). If ==true, provide code block has executed successfully.\n\nSteps:\n\nIf cb::AICode has not been evaluated, cb.success = nothing.  After the evaluation it will be either true or false depending on the outcome\nParse the text in cb.code\nEvaluate the parsed expression\nCapture outputs of the evaluated in cb.output\n[OPTIONAL] Capture any stdout outputs (eg, test failures) in cb.stdout\nIf any error exception is raised, it is saved in cb.error\nFinally, if all steps were successful, success is set to cb.success = true\n\nKeyword Arguments\n\nsafe_eval::Bool: If true, we first check for any Pkg operations (eg, installing new packages) and missing imports,  then the code will be evaluated inside a bespoke scratch module (not to change any user variables)\ncapture_stdout::Bool: If true, we capture any stdout outputs (eg, test failures) in cb.stdout\nprefix::AbstractString: A string to be prepended to the code block before parsing and evaluation. Useful to add some additional code definition or necessary imports. Defaults to an empty string.\nsuffix::AbstractString: A string to be appended to the code block before parsing and evaluation.  Useful to check that tests pass or that an example executes. Defaults to an empty string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.extract_code_blocks-Tuple{T} where T<:AbstractString","page":"PromptingTools.jl","title":"PromptingTools.extract_code_blocks","text":"extract_code_blocks(markdown_content::String) -> Vector{String}\n\nExtract Julia code blocks from a markdown string.\n\nThis function searches through the provided markdown content, identifies blocks of code specifically marked as Julia code  (using the julia ... code fence patterns), and extracts the code within these blocks.  The extracted code blocks are returned as a vector of strings, with each string representing one block of Julia code. \n\nNote: Only the content within the code fences is extracted, and the code fences themselves are not included in the output.\n\nSee also: extract_code_blocks_fallback\n\nArguments\n\nmarkdown_content::String: A string containing the markdown content from which Julia code blocks are to be extracted.\n\nReturns\n\nVector{String}: A vector containing strings of extracted Julia code blocks. If no Julia code blocks are found, an empty vector is returned.\n\nExamples\n\nExample with a single Julia code block\n\nmarkdown_single = \"\"\"\n\njulia println(\"Hello, World!\")\n\n\"\"\"\nextract_code_blocks(markdown_single)\n# Output: [\"Hello, World!\"]\n\n# Example with multiple Julia code blocks\nmarkdown_multiple = \"\"\"\n\njulia x = 5\n\nSome text in between\n\njulia y = x + 2\n\n\"\"\"\nextract_code_blocks(markdown_multiple)\n# Output: [\"x = 5\", \"y = x + 2\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.extract_code_blocks_fallback-Union{Tuple{T}, Tuple{T, AbstractString}} where T<:AbstractString","page":"PromptingTools.jl","title":"PromptingTools.extract_code_blocks_fallback","text":"extract_code_blocks_fallback(markdown_content::String, delim::AbstractString=\"\\n```\\n\")\n\nExtract Julia code blocks from a markdown string using a fallback method (splitting by arbitrary delim-iters). Much more simplistic than extract_code_blocks and does not support nested code blocks.\n\nIt is often used as a fallback for smaller LLMs that forget to code fence julia ....\n\nExample\n\ncode = \"\"\"\n\nprintln(\"hello\")\n\n\nSome text\n\n\nprintln(\"world\")\n\n\"\"\"\n\n# We extract text between triple backticks and check each blob if it looks like a valid Julia code\ncode_parsed = extract_code_blocks_fallback(code) |> x -> filter(is_julia_code, x) |> x -> join(x, \"\n\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.extract_function_name-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.extract_function_name","text":"extract_function_name(code_block::String) -> Union{String, Nothing}\n\nExtract the name of a function from a given Julia code block. The function searches for two patterns:\n\nThe explicit function declaration pattern: function name(...) ... end\nThe concise function declaration pattern: name(...) = ...\n\nIf a function name is found, it is returned as a string. If no function name is found, the function returns nothing.\n\nTo capture all function names in the block, use extract_function_names.\n\nArguments\n\ncode_block::String: A string containing Julia code.\n\nReturns\n\nUnion{String, Nothing}: The extracted function name or nothing if no name is found.\n\nExample\n\ncode = \"\"\"\nfunction myFunction(arg1, arg2)\n    # Function body\nend\n\"\"\"\nextract_function_name(code)\n# Output: \"myFunction\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.extract_function_names-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.extract_function_names","text":"extract_function_names(code_block::AbstractString)\n\nExtract one or more names of functions defined in a given Julia code block. The function searches for two patterns:     - The explicit function declaration pattern: function name(...) ... end     - The concise function declaration pattern: name(...) = ...\n\nIt always returns a vector of strings, even if only one function name is found (it will be empty).\n\nFor only one function name match, use extract_function_name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.extract_julia_imports-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.extract_julia_imports","text":"extract_julia_imports(input::AbstractString; base_or_main::Bool = false)\n\nDetects any using or import statements in a given string and returns the package names as a vector of symbols. \n\nbase_or_main is a boolean that determines whether to isolate only Base and Main OR whether to exclude them in the returned vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.finalize_outputs-Tuple{Union{AbstractString, PromptingTools.AbstractMessage, Vector{<:PromptingTools.AbstractMessage}}, Any, Union{Nothing, PromptingTools.AbstractMessage, AbstractVector{<:PromptingTools.AbstractMessage}}}","page":"PromptingTools.jl","title":"PromptingTools.finalize_outputs","text":"finalize_outputs(prompt::ALLOWED_PROMPT_TYPE, conv_rendered::Any,\n    msg::Union{Nothing, AbstractMessage, AbstractVector{<:AbstractMessage}};\n    return_all::Bool = false,\n    dry_run::Bool = false,\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    kwargs...)\n\nFinalizes the outputs of the ai* functions by either returning the conversation history or the last message.\n\nKeyword arguments\n\nreturn_all::Bool=false: If true, returns the entire conversation history, otherwise returns only the last message (the AIMessage).\ndry_run::Bool=false: If true, does not send the messages to the model, but only renders the prompt with the given schema and replacement variables. Useful for debugging when you want to check the specific schema rendering. \nconversation::AbstractVector{<:AbstractMessage}=[]: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\nkwargs...: Variables to replace in the prompt template.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.find_subsequence_positions-Tuple{Any, Any}","page":"PromptingTools.jl","title":"PromptingTools.find_subsequence_positions","text":"find_subsequence_positions(subseq, seq) -> Vector{Int}\n\nFind all positions of a subsequence subseq within a larger sequence seq. Used to lookup positions of code blocks in markdown.\n\nThis function scans the sequence seq and identifies all starting positions where the subsequence subseq is found. Both subseq and seq should be vectors of integers, typically obtained using codeunits on strings.\n\nArguments\n\nsubseq: A vector of integers representing the subsequence to search for.\nseq: A vector of integers representing the larger sequence in which to search.\n\nReturns\n\nVector{Int}: A vector of starting positions (1-based indices) where the subsequence is found in the sequence.\n\nExamples\n\nfind_subsequence_positions(codeunits(\"ab\"), codeunits(\"cababcab\")) # Returns [2, 5]\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.function_call_signature-Tuple{Type}","page":"PromptingTools.jl","title":"PromptingTools.function_call_signature","text":"function_call_signature(datastructtype::Struct; max_description_length::Int = 100)\n\nExtract the argument names, types and docstrings from a struct to create the function call signature in JSON schema.\n\nYou must provide a Struct type (not an instance of it) with some fields.\n\nNote: Fairly experimental, but works for combination of structs, arrays, strings and singletons.\n\nTips\n\nYou can improve the quality of the extraction by writing a helpful docstring for your struct (or any nested struct). It will be provided as a description. \n\nYou can even include comments/descriptions about the individual fields.\n\nAll fields are assumed to be required, unless you allow null values (eg, ::Union{Nothing, Int}). Fields with Nothing will be treated as optional.\nMissing values are ignored (eg, ::Union{Missing, Int} will be treated as Int). It's for broader compatibility and we cannot deserialize it as easily as Nothing.\n\nExample\n\nDo you want to extract some specific measurements from a text like age, weight and height? You need to define the information you need as a struct (return_type):\n\nstruct MyMeasurement\n    age::Int\n    height::Union{Int,Nothing}\n    weight::Union{Nothing,Float64}\nend\nsignature = function_call_signature(MyMeasurement)\n#\n# Dict{String, Any} with 3 entries:\n#   \"name\"        => \"MyMeasurement_extractor\"\n#   \"parameters\"  => Dict{String, Any}(\"properties\"=>Dict{String, Any}(\"height\"=>Dict{String, Any}(\"type\"=>\"integer\"), \"weight\"=>Dic…\n#   \"description\" => \"Represents person's age, height, and weight\n\"\n\nYou can see that only the field age does not allow null values, hence, it's \"required\". While height and weight are optional.\n\nsignature[\"parameters\"][\"required\"]\n# [\"age\"]\n\nIf there are multiple items you want to extract, define a wrapper struct to get a Vector of MyMeasurement:\n\nstruct MyMeasurementWrapper\n    measurements::Vector{MyMeasurement}\nend\n\nOr if you want your extraction to fail gracefully when data isn't found, use `MaybeExtract{T}` wrapper (inspired by Instructor package!):\n\nusing PromptingTools: MaybeExtract\n\ntype = MaybeExtract{MyMeasurement}\n\nEffectively the same as:\n\nstruct MaybeExtract{T}\n\nresult::Union{T, Nothing}\n\nerror::Bool // true if a result is found, false otherwise\n\nmessage::Union{Nothing, String} // Only present if no result is found, should be short and concise\n\nend\n\nIf LLM extraction fails, it will return a Dict with error and message fields instead of the result!\n\nmsg = aiextract(\"Extract measurements from the text: I am giraffe\", type)\n\n\n\nDict{Symbol, Any} with 2 entries:\n\n:message => \"Sorry, this feature is only available for humans.\"\n\n:error   => true\n\n``` That way, you can handle the error gracefully and get a reason why extraction failed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.get_preferences-Tuple{String}","page":"PromptingTools.jl","title":"PromptingTools.get_preferences","text":"get_preferences(key::String)\n\nGet preferences for PromptingTools. See ?PREFERENCES for more information.\n\nSee also: set_preferences!\n\nExample\n\nPromptingTools.get_preferences(\"MODEL_CHAT\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.ggi_generate_content","page":"PromptingTools.jl","title":"PromptingTools.ggi_generate_content","text":"Stub - to be extended in extension: GoogleGenAIPromptingToolsExt. ggi stands for GoogleGenAI\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.has_julia_prompt-Tuple{T} where T<:AbstractString","page":"PromptingTools.jl","title":"PromptingTools.has_julia_prompt","text":"Checks if a given string has a Julia prompt (julia>) at the beginning of a line.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.length_longest_common_subsequence-Tuple{Any, Any}","page":"PromptingTools.jl","title":"PromptingTools.length_longest_common_subsequence","text":"length_longest_common_subsequence(itr1, itr2)\n\nCompute the length of the longest common subsequence between two sequences (ie, the higher the number, the better the match).\n\nSource: https://cn.julialang.org/LeetCode.jl/dev/democards/problems/problems/1143.longest-common-subsequence/\n\nArguments\n\nitr1: The first sequence, eg, a String.\nitr2: The second sequence, eg, a String.\n\nReturns\n\nThe length of the longest common subsequence.\n\nExamples\n\ntext1 = \"abc-abc----\"\ntext2 = \"___ab_c__abc\"\nlongest_common_subsequence(text1, text2)\n# Output: 6 (-> \"abcabc\")\n\nIt can be used to fuzzy match strings and find the similarity between them (Tip: normalize the match)\n\ncommands = [\"product recommendation\", \"emotions\", \"specific product advice\", \"checkout advice\"]\nquery = \"Which product can you recommend for me?\"\nlet pos = argmax(length_longest_common_subsequence.(Ref(query), commands))\n    dist = length_longest_common_subsequence(query, commands[pos])\n    norm = dist / min(length(query), length(commands[pos]))\n    @info \"The closest command to the query: \"$(query)\" is: \"$(commands[pos])\" (distance: $(dist), normalized: $(norm))\"\nend\n\nYou can also use it to find the closest context for some AI generated summary/story:\n\ncontext = [\"The enigmatic stranger vanished as swiftly as a wisp of smoke, leaving behind a trail of unanswered questions.\",\n    \"Beneath the shimmering moonlight, the ocean whispered secrets only the stars could hear.\",\n    \"The ancient tree stood as a silent guardian, its gnarled branches reaching for the heavens.\",\n    \"The melody danced through the air, painting a vibrant tapestry of emotions.\",\n    \"Time flowed like a relentless river, carrying away memories and leaving imprints in its wake.\"]\n\nstory = \"\"\"\n  Beneath the shimmering moonlight, the ocean whispered secrets only the stars could hear.\n\n  Under the celestial tapestry, the vast ocean whispered its secrets to the indifferent stars. Each ripple, a murmured confidence, each wave, a whispered lament. The glittering celestial bodies listened in silent complicity, their enigmatic gaze reflecting the ocean's unspoken truths. The cosmic dance between the sea and the sky, a symphony of shared secrets, forever echoing in the ethereal expanse.\n  \"\"\"\n\nlet pos = argmax(length_longest_common_subsequence.(Ref(story), context))\n    dist = length_longest_common_subsequence(story, context[pos])\n    norm = dist / min(length(story), length(context[pos]))\n    @info \"The closest context to the query: \"$(first(story,20))...\" is: \"$(context[pos])\" (distance: $(dist), normalized: $(norm))\"\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.list_aliases-Tuple{}","page":"PromptingTools.jl","title":"PromptingTools.list_aliases","text":"Shows the Dictionary of model aliases in the registry. Add more with MODEL_ALIASES[alias] = model_name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.list_registry-Tuple{}","page":"PromptingTools.jl","title":"PromptingTools.list_registry","text":"Shows the list of models in the registry. Add more with register_model!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.load_conversation-Tuple{Union{AbstractString, IO}}","page":"PromptingTools.jl","title":"PromptingTools.load_conversation","text":"Loads a conversation (messages) from io_or_file\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.load_template-Tuple{Union{AbstractString, IO}}","page":"PromptingTools.jl","title":"PromptingTools.load_template","text":"Loads messaging template from io_or_file and returns tuple of template messages and metadata.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.load_templates!","page":"PromptingTools.jl","title":"PromptingTools.load_templates!","text":"load_templates!(; remove_templates::Bool=true)\n\nLoads templates from folder templates/ in the package root and stores them in TEMPLATE_STORE and TEMPLATE_METADATA.\n\nNote: Automatically removes any existing templates and metadata from TEMPLATE_STORE and TEMPLATE_METADATA if remove_templates=true.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.ollama_api","page":"PromptingTools.jl","title":"PromptingTools.ollama_api","text":"ollama_api(prompt_schema::Union{AbstractOllamaManagedSchema, AbstractOllamaSchema},\n    prompt::Union{AbstractString, Nothing} = nothing;\n    system::Union{Nothing, AbstractString} = nothing,\n    messages::Vector{<:AbstractMessage} = AbstractMessage[],\n    endpoint::String = \"generate\",\n    model::String = \"llama2\", http_kwargs::NamedTuple = NamedTuple(),\n    stream::Bool = false,\n    url::String = \"localhost\", port::Int = 11434,\n    kwargs...)\n\nSimple wrapper for a call to Ollama API.\n\nKeyword Arguments\n\nprompt_schema: Defines which prompt template should be applied.\nprompt: Can be a string representing the prompt for the AI conversation, a UserMessage, a vector of AbstractMessage\nsystem: An optional string representing the system message for the AI conversation. If not provided, a default message will be used.\nendpoint: The API endpoint to call, only \"generate\" and \"embeddings\" are currently supported. Defaults to \"generate\".\nmodel: A string representing the model to use for generating the response. Can be an alias corresponding to a model ID defined in MODEL_ALIASES.\nhttp_kwargs::NamedTuple: Additional keyword arguments for the HTTP request. Defaults to empty NamedTuple.\nstream: A boolean indicating whether to stream the response. Defaults to false.\nurl: The URL of the Ollama API. Defaults to \"localhost\".\nport: The port of the Ollama API. Defaults to 11434.\nkwargs: Prompt variables to be used to fill the prompt/template\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.preview","page":"PromptingTools.jl","title":"PromptingTools.preview","text":"Utility for rendering the conversation (vector of messages) as markdown. REQUIRES the Markdown package to load the extension!\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.push_conversation!-Tuple{Vector{<:Vector}, AbstractVector, Union{Nothing, Int64}}","page":"PromptingTools.jl","title":"PromptingTools.push_conversation!","text":"push_conversation!(conv_history, conversation::AbstractVector, max_history::Union{Int, Nothing})\n\nAdd a new conversation to the conversation history and resize the history if necessary.\n\nThis function appends a conversation to the conv_history, which is a vector of conversations. Each conversation is represented as a vector of AbstractMessage objects. After adding the new conversation, the history is resized according to the max_history parameter to ensure that the size of the history does not exceed the specified limit.\n\nArguments\n\nconv_history: A vector that stores the history of conversations. Typically, this is PT.CONV_HISTORY.\nconversation: The new conversation to be added. It should be a vector of AbstractMessage objects.\nmax_history: The maximum number of conversations to retain in the history. If Nothing, the history is not resized.\n\nReturns\n\nThe updated conversation history.\n\nExample\n\nnew_conversation = aigenerate(\"Hello World\"; return_all = true)\npush_conversation!(PT.CONV_HISTORY, new_conversation, 10)\n\nThis is done automatically by the ai\"\" macros.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.register_model!","page":"PromptingTools.jl","title":"PromptingTools.register_model!","text":"register_model!(registry = MODEL_REGISTRY;\n    name::String,\n    schema::Union{AbstractPromptSchema, Nothing} = nothing,\n    cost_of_token_prompt::Float64 = 0.0,\n    cost_of_token_generation::Float64 = 0.0,\n    description::String = \"\")\n\nRegister a new AI model with name and its associated schema. \n\nRegistering a model helps with calculating the costs and automatically selecting the right prompt schema.\n\nArguments\n\nname: The name of the model. This is the name that will be used to refer to the model in the ai* functions.\nschema: The schema of the model. This is the schema that will be used to generate prompts for the model, eg, OpenAISchema().\ncost_of_token_prompt: The cost of a token in the prompt for this model. This is used to calculate the cost of a prompt.   Note: It is often provided online as cost per 1000 tokens, so make sure to convert it correctly!\ncost_of_token_generation: The cost of a token generated by this model. This is used to calculate the cost of a generation.   Note: It is often provided online as cost per 1000 tokens, so make sure to convert it correctly!\ndescription: A description of the model. This is used to provide more information about the model when it is queried.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PromptingTools.remove_julia_prompt-Tuple{T} where T<:AbstractString","page":"PromptingTools.jl","title":"PromptingTools.remove_julia_prompt","text":"remove_julia_prompt(s::T) where {T<:AbstractString}\n\nIf it detects a julia prompt, it removes it and all lines that do not have it (except for those that belong to the code block).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.remove_templates!-Tuple{}","page":"PromptingTools.jl","title":"PromptingTools.remove_templates!","text":"    remove_templates!()\n\nRemoves all templates from TEMPLATE_STORE and TEMPLATE_METADATA.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.remove_unsafe_lines-Tuple{AbstractString}","page":"PromptingTools.jl","title":"PromptingTools.remove_unsafe_lines","text":"Iterates over the lines of a string and removes those that contain a package operation or a missing import.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{AITemplate}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"Renders provided messaging template (template) under the default schema (PROMPT_SCHEMA).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{PromptingTools.AbstractGoogleSchema, Vector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"render(schema::AbstractGoogleSchema,\n    messages::Vector{<:AbstractMessage};\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    kwargs...)\n\nBuilds a history of the conversation to provide the prompt to the API. All unspecified kwargs are passed as replacements such that {{key}}=>value in the template.\n\nKeyword Arguments\n\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{PromptingTools.AbstractOllamaManagedSchema, Vector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"render(schema::AbstractOllamaManagedSchema,\n    messages::Vector{<:AbstractMessage};\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    kwargs...)\n\nBuilds a history of the conversation to provide the prompt to the API. All unspecified kwargs are passed as replacements such that {{key}}=>value in the template.\n\nNote: Due to its \"managed\" nature, at most 2 messages can be provided (system and prompt inputs in the API).\n\nKeyword Arguments\n\nconversation: Not allowed for this schema. Provided only for compatibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{PromptingTools.AbstractOllamaSchema, Vector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"render(schema::AbstractOllamaSchema,\n    messages::Vector{<:AbstractMessage};\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    kwargs...)\n\nBuilds a history of the conversation to provide the prompt to the API. All unspecified kwargs are passed as replacements such that {{key}}=>value in the template.\n\nKeyword Arguments\n\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{PromptingTools.AbstractOpenAISchema, Vector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"render(schema::AbstractOpenAISchema,\n    messages::Vector{<:AbstractMessage};\n    image_detail::AbstractString = \"auto\",\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    kwargs...)\n\nBuilds a history of the conversation to provide the prompt to the API. All unspecified kwargs are passed as replacements such that {{key}}=>value in the template.\n\nKeyword Arguments\n\nimage_detail: Only for UserMessageWithImages. It represents the level of detail to include for images. Can be \"auto\", \"high\", or \"low\".\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.render-Tuple{PromptingTools.NoSchema, Vector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.render","text":"render(schema::NoSchema,\n    messages::Vector{<:AbstractMessage};\n    conversation::AbstractVector{<:AbstractMessage} = AbstractMessage[],\n    replacement_kwargs...)\n\nRenders a conversation history from a vector of messages with all replacement variables specified in replacement_kwargs.\n\nIt is the first pass of the prompt rendering system, and is used by all other schemas.\n\nKeyword Arguments\n\nimage_detail: Only for UserMessageWithImages. It represents the level of detail to include for images. Can be \"auto\", \"high\", or \"low\".\nconversation: An optional vector of AbstractMessage objects representing the conversation history. If not provided, it is initialized as an empty vector.\n\nNotes\n\nAll unspecified kwargs are passed as replacements such that {{key}}=>value in the template.\nIf a SystemMessage is missing, we inject a default one at the beginning of the conversation.\nOnly one SystemMessage is allowed (ie, cannot mix two conversations different system prompts).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.replace_words-Tuple{AbstractString, Vector{<:AbstractString}}","page":"PromptingTools.jl","title":"PromptingTools.replace_words","text":"replace_words(text::AbstractString, words::Vector{<:AbstractString}; replacement::AbstractString=\"ABC\")\n\nReplace all occurrences of words in words with replacement in text. Useful to quickly remove specific names or entities from a text.\n\nArguments\n\ntext::AbstractString: The text to be processed.\nwords::Vector{<:AbstractString}: A vector of words to be replaced.\nreplacement::AbstractString=\"ABC\": The replacement string to be used. Defaults to \"ABC\".\n\nExample\n\ntext = \"Disney is a great company\"\nreplace_words(text, [\"Disney\", \"Snow White\", \"Mickey Mouse\"])\n# Output: \"ABC is a great company\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.resize_conversation!-Tuple{Any, Union{Nothing, Int64}}","page":"PromptingTools.jl","title":"PromptingTools.resize_conversation!","text":"resize_conversation!(conv_history, max_history::Union{Int, Nothing})\n\nResize the conversation history to a specified maximum length.\n\nThis function trims the conv_history to ensure that its size does not exceed max_history. It removes the oldest conversations first if the length of conv_history is greater than max_history.\n\nArguments\n\nconv_history: A vector that stores the history of conversations. Typically, this is PT.CONV_HISTORY.\nmax_history: The maximum number of conversations to retain in the history. If Nothing, the history is not resized.\n\nReturns\n\nThe resized conversation history.\n\nExample\n\nresize_conversation!(PT.CONV_HISTORY, PT.MAX_HISTORY_LENGTH)\n\nAfter the function call, conv_history will contain only the 10 most recent conversations.\n\nThis is done automatically by the ai\"\" macros.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.response_to_message-Tuple{PromptingTools.AbstractOpenAISchema, Type{AIMessage}, Any, Any}","page":"PromptingTools.jl","title":"PromptingTools.response_to_message","text":"response_to_message(schema::AbstractOpenAISchema,\n    MSG::Type{AIMessage},\n    choice,\n    resp;\n    model_id::AbstractString = \"\",\n    time::Float64 = 0.0,\n    run_id::Integer = rand(Int16),\n    sample_id::Union{Nothing, Integer} = nothing)\n\nUtility to facilitate unwrapping of HTTP response to a message type MSG provided for OpenAI-like responses\n\nNote: Extracts finish_reason and log_prob if available in the response.\n\nArguments\n\nschema::AbstractOpenAISchema: The schema for the prompt.\nMSG::Type{AIMessage}: The message type to be returned.\nchoice: The choice from the response (eg, one of the completions).\nresp: The response from the OpenAI API.\nmodel_id::AbstractString: The model ID to use for generating the response. Defaults to an empty string.\ntime::Float64: The elapsed time for the response. Defaults to 0.0.\nrun_id::Integer: The run ID for the response. Defaults to a random integer.\nsample_id::Union{Nothing, Integer}: The sample ID for the response (if there are multiple completions). Defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.response_to_message-Union{Tuple{T}, Tuple{PromptingTools.AbstractPromptSchema, Type{T}, Any, Any}} where T","page":"PromptingTools.jl","title":"PromptingTools.response_to_message","text":"Utility to facilitate unwrapping of HTTP response to a message type MSG provided. Designed to handle multi-sample completions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.save_conversation-Tuple{Union{AbstractString, IO}, AbstractVector{<:PromptingTools.AbstractMessage}}","page":"PromptingTools.jl","title":"PromptingTools.save_conversation","text":"Saves provided conversation (messages) to io_or_file. If you need to add some metadata, see save_template.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.save_template-Tuple{Union{AbstractString, IO}, AbstractVector{<:PromptingTools.AbstractChatMessage}}","page":"PromptingTools.jl","title":"PromptingTools.save_template","text":"Saves provided messaging template (messages) to io_or_file. Automatically adds metadata based on provided keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.set_preferences!-Tuple{Vararg{Pair{String}}}","page":"PromptingTools.jl","title":"PromptingTools.set_preferences!","text":"set_preferences!(pairs::Pair{String, <:Any}...)\n\nSet preferences for PromptingTools. See ?PREFERENCES for more information. \n\nSee also: get_preferences\n\nExample\n\nChange your API key and default model:\n\nPromptingTools.set_preferences!(\"OPENAI_API_KEY\" => \"key1\", \"MODEL_CHAT\" => \"chat1\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.split_by_length-Tuple{Any, Vector{String}}","page":"PromptingTools.jl","title":"PromptingTools.split_by_length","text":"split_by_length(text::String, separators::Vector{String}; max_length::Int=35000) -> Vector{String}\n\nSplit a given string text into chunks using a series of separators, with each chunk having a maximum length of max_length.  This function is useful for splitting large documents or texts into smaller segments that are more manageable for processing, particularly for models or systems with limited context windows.\n\nArguments\n\ntext::String: The text to be split.\nseparators::Vector{String}: An ordered list of separators used to split the text. The function iteratively applies these separators to split the text.\nmax_length::Int=35000: The maximum length of each chunk. Defaults to 35,000 characters. This length is considered after each iteration of splitting, ensuring chunks fit within specified constraints.\n\nReturns\n\nVector{String}: A vector of strings, where each string is a chunk of the original text that is smaller than or equal to max_length.\n\nNotes\n\nThe function processes the text iteratively with each separator in the provided order. This ensures more nuanced splitting, especially in structured texts.\nEach chunk is as close to max_length as possible without exceeding it (unless we cannot split it any further)\nIf the text is empty, the function returns an empty array.\nSeparators are re-added to the text chunks after splitting, preserving the original structure of the text as closely as possible. Apply strip if you do not need them.\n\nExamples\n\nSplitting text using multiple separators:\n\ntext = \"Paragraph 1\n\nParagraph 2. Sentence 1. Sentence 2.\nParagraph 3\"\nseparators = [\"\n\n\", \". \", \"\n\"]\nchunks = split_by_length(text, separators, max_length=20)\n\nUsing a single separator:\n\ntext = \"Hello,World,\" ^ 2900  # length 34900 characters\nchunks = split_by_length(text, [\",\"], max_length=10000)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.split_by_length-Tuple{String}","page":"PromptingTools.jl","title":"PromptingTools.split_by_length","text":"split_by_length(text::String; separator::String=\" \", max_length::Int=35000) -> Vector{String}\n\nSplit a given string text into chunks of a specified maximum length max_length.  This is particularly useful for splitting larger documents or texts into smaller segments, suitable for models or systems with smaller context windows.\n\nArguments\n\ntext::String: The text to be split.\nseparator::String=\" \": The separator used to split the text into minichunks. Defaults to a space character.\nmax_length::Int=35000: The maximum length of each chunk. Defaults to 35,000 characters, which should fit within 16K context window.\n\nReturns\n\nVector{String}: A vector of strings, each representing a chunk of the original text that is smaller than or equal to max_length.\n\nNotes\n\nThe function ensures that each chunk is as close to max_length as possible without exceeding it.\nIf the text is empty, the function returns an empty array.\nThe separator is re-added to the text chunks after splitting, preserving the original structure of the text as closely as possible.\n\nExamples\n\nSplitting text with the default separator (\" \"):\n\ntext = \"Hello world. How are you?\"\nchunks = split_by_length(text; max_length=13)\nlength(chunks) # Output: 2\n\nUsing a custom separator and custom max_length\n\ntext = \"Hello,World,\" ^ 2900 # length 34900 chars\nsplit_by_length(text; separator=\",\", max_length=10000) # for 4K context window\nlength(chunks[1]) # Output: 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#PromptingTools.@aai_str-Tuple{Any, Vararg{Any}}","page":"PromptingTools.jl","title":"PromptingTools.@aai_str","text":"aai\"user_prompt\"[model_alias] -> AIMessage\n\nAsynchronous version of @ai_str macro, which will log the result once it's ready.\n\nSee also aai!\"\" if you want an asynchronous reply to the provided message / continue the conversation.    \n\nExample\n\nSend asynchronous request to GPT-4, so we don't have to wait for the response: Very practical with slow models, so you can keep working in the meantime.\n\n```julia m = aai\"Say Hi!\"gpt4; \n\n...with some delay...\n\n[ Info: Tokens: 29 @ Cost: 0.0011 in 2.7 seconds\n\n[ Info: AIMessage> Hello! How can I assist you today?\n\n\n\n\n\n","category":"macro"},{"location":"reference/#PromptingTools.@ai!_str-Tuple{Any, Vararg{Any}}","page":"PromptingTools.jl","title":"PromptingTools.@ai!_str","text":"ai!\"user_prompt\"[model_alias] -> AIMessage\n\nThe ai!\"\" string macro is used to continue a previous conversation with the AI model. \n\nIt appends the new user prompt to the last conversation in the tracked history (in PromptingTools.CONV_HISTORY) and generates a response based on the entire conversation context. If you want to see the previous conversation, you can access it via PromptingTools.CONV_HISTORY, which keeps at most last PromptingTools.MAX_HISTORY_LENGTH conversations.\n\nArguments\n\nuser_prompt (String): The new input prompt to be added to the existing conversation.\nmodel_alias (optional, any): Specify the model alias of the AI model to be used (see MODEL_ALIASES). If not provided, the default model is used.\n\nReturns\n\nAIMessage corresponding to the new user prompt, considering the entire conversation history.\n\nExample\n\nTo continue a conversation:\n\n# start conversation as normal\nai\"Say hi.\" \n\n# ... wait for reply and then react to it:\n\n# continue the conversation (notice that you can change the model, eg, to more powerful one for better answer)\nai!\"What do you think about that?\"gpt4t\n# AIMessage(\"Considering our previous discussion, I think that...\")\n\nUsage Notes\n\nThis macro should be used when you want to maintain the context of an ongoing conversation (ie, the last ai\"\" message).\nIt automatically accesses and updates the global conversation history.\nIf no conversation history is found, it raises an assertion error, suggesting to initiate a new conversation using ai\"\" instead.\n\nImportant\n\nEnsure that the conversation history is not too long to maintain relevancy and coherence in the AI's responses. The history length is managed by MAX_HISTORY_LENGTH.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#PromptingTools.@ai_str-Tuple{Any, Vararg{Any}}","page":"PromptingTools.jl","title":"PromptingTools.@ai_str","text":"ai\"user_prompt\"[model_alias] -> AIMessage\n\nThe ai\"\" string macro generates an AI response to a given prompt by using aigenerate under the hood.\n\nSee also ai!\"\" if you want to reply to the provided message / continue the conversation.\n\nArguments\n\nuser_prompt (String): The input prompt for the AI model.\nmodel_alias (optional, any): Provide model alias of the AI model (see MODEL_ALIASES).\n\nReturns\n\nAIMessage corresponding to the input prompt.\n\nExample\n\nresult = ai\"Hello, how are you?\"\n# AIMessage(\"Hello! I'm an AI assistant, so I don't have feelings, but I'm here to help you. How can I assist you today?\")\n\nIf you want to interpolate some variables or additional context, simply use string interpolation:\n\na=1\nresult = ai\"What is `$a+$a`?\"\n# AIMessage(\"The sum of `1+1` is `2`.\")\n\nIf you want to use a different model, eg, GPT-4, you can provide its alias as a flag:\n\nresult = ai\"What is `1.23 * 100 + 1`?\"gpt4t\n# AIMessage(\"The answer is 124.\")\n\n\n\n\n\n","category":"macro"},{"location":"reference/#PromptingTools.@timeout-Tuple{Any, Any, Any}","page":"PromptingTools.jl","title":"PromptingTools.@timeout","text":"@timeout(seconds, expr_to_run, expr_when_fails)\n\nSimple macro to run an expression with a timeout of seconds. If the expr_to_run fails to finish in seconds seconds, expr_when_fails is returned.\n\nExample\n\nx = @timeout 1 begin\n    sleep(1.1)\n    println(\"done\")\n    1\nend \"failed\"\n\n\n\n\n\n\n","category":"macro"},{"location":"reference_agenttools/#Reference-for-AgentTools","page":"AgentTools","title":"Reference for AgentTools","text":"","category":"section"},{"location":"reference_agenttools/","page":"AgentTools","title":"AgentTools","text":"Modules = [PromptingTools.Experimental.AgentTools]","category":"page"},{"location":"reference_agenttools/","page":"AgentTools","title":"AgentTools","text":"Modules = [PromptingTools.Experimental.AgentTools]","category":"page"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools","text":"AgentTools\n\nProvides Agentic functionality providing lazy calls for building pipelines (eg, AIGenerate) and AICodeFixer.\n\nThis module is experimental and may change at any time. It is intended to be moved to a separate package in the future.\n\n\n\n\n\n","category":"module"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AICall","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AICall","text":"AICall(func::F, args...; kwargs...) where {F<:Function}\n\nAIGenerate(args...; kwargs...)\nAIEmbed(args...; kwargs...)\nAIExtract(args...; kwargs...)\n\nA lazy call wrapper for AI functions in the PromptingTools module, such as aigenerate.\n\nThe AICall struct is designed to facilitate a deferred execution model (lazy evaluation) for AI functions that interact with a Language Learning Model (LLM). It stores the necessary information for an AI call and executes the underlying AI function only when supplied with a UserMessage or when the run! method is applied. This approach allows for more flexible and efficient handling of AI function calls, especially in interactive environments.\n\nSeel also: run!, AICodeFixer\n\nFields\n\nfunc::F: The AI function to be called lazily. This should be a function like aigenerate or other ai* functions.\nschema::Union{Nothing, PT.AbstractPromptSchema}: Optional schema to structure the prompt for the AI function.\nconversation::Vector{PT.AbstractMessage}: A vector of messages that forms the conversation context for the AI call.\nkwargs::NamedTuple: Keyword arguments to be passed to the AI function.\nsuccess::Union{Nothing, Bool}: Indicates whether the last call was successful (true) or not (false). Nothing if the call hasn't been made yet.\nerror::Union{Nothing, Exception}: Stores any exception that occurred during the last call. Nothing if no error occurred or if the call hasn't been made yet.\n\nExample\n\nInitiate an AICall like any ai* function, eg, AIGenerate:\n\naicall = AICall(aigenerate)\n\n# With arguments and kwargs like ai* functions\n# from `aigenerate(schema, conversation; model=\"abc\", api_kwargs=(; temperature=0.1))`\n# to\naicall = AICall(aigenerate, schema, conversation; model=\"abc\", api_kwargs=(; temperature=0.1)\n\n# Or with a template\naicall = AIGenerate(:JuliaExpertAsk; ask=\"xyz\", model=\"abc\", api_kwargs=(; temperature=0.1))\n\nTrigger the AICall with run! (it returns the update AICall struct back):\n\naicall |> run!\n````\n\nYou can also use `AICall` as a functor to trigger the AI call with a `UserMessage` or simply the text to send:\n\njulia aicall(UserMessage(\"Hello, world!\"))  # Triggers the lazy call result = run!(aicall)  # Explicitly runs the AI call ``` This can be used to \"reply\" to previous message / continue the stored conversation\n\nNotes\n\nThe AICall struct is a key component in building flexible and efficient Agentic pipelines\nThe lazy evaluation model allows for setting up the call parameters in advance and deferring the actual execution until it is explicitly triggered.\nThis struct is particularly useful in scenarios where the timing of AI function execution needs to be deferred or where multiple potential calls need to be prepared and selectively executed.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AICodeFixer","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AICodeFixer","text":"AICodeFixer(aicall::AICall, templates::Vector{<:PT.UserMessage}; num_rounds::Int = 3, feedback_func::Function = aicodefixer_feedback; kwargs...)\nAICodeFixer(aicall::AICall, template::Union{AITemplate, Symbol} = :CodeFixerRCI; kwargs...)\n\nAn AIAgent that iteratively evaluates any received Julia code and provides feedback back to the AI model if num_rounds>0. AICodeFixer manages the lifecycle of a code fixing session, including tracking conversation history, rounds of interaction, and applying user feedback through a specialized feedback function.\n\nIt integrates with lazy AI call structures like AIGenerate. \n\nThe operation is \"lazy\", ie, the agent is only executed when needed, eg, when run! is called.\n\nFields\n\ncall::AICall: The AI call that is being used for code generation or processing, eg, AIGenerate (same as aigenerate but \"lazy\", ie, called only when needed\ntemplates::Union{Symbol, AITemplate, Vector{PT.UserMessage}}: A set of user messages or templates that guide the AI's code fixing process.  The first UserMessage is used in the first round of code fixing, the second UserMessage is used for every subsequent iteration.\nnum_rounds::Int: The number of rounds for the code fixing session. Defaults to 3.\nround_counter::Int: Counter to track the current round of interaction.\nfeedback_func::Function: Function to generate feedback based on the AI's proposed code, defaults to aicodefixer_feedback  (modular thanks to type dispatch on AbstractOutcomes)\nkwargs::NamedTuple: Additional keyword arguments for customizing the AI call.\n\nNote: Any kwargs provided to run!() will be passed to the underlying AICall.\n\nExample\n\nLet's create an AIGenerate call and then pipe it to AICodeFixer to run a few rounds of the coding fixing:\n\n# Create an AIGenerate call\nlazy_call = AIGenerate(\"Write a function to do XYZ...\")\n\n# the action starts only when `run!` is called\nresult = lazy_call |> AICodeFixer |> run!\n\n# Access the result of the code fixing session\n# result.call refers to the AIGenerate lazy call above\nconversation = result.call.conversation\nfixed_code = last(conversation) # usually in the last message\n\n# Preview the conversation history\npreview(conversation)\n\nYou can change the template used to provide user feedback and number of counds via arguments:\n\n# Setup an AIGenerate call\nlazy_call = AIGenerate(aigenerate, \"Write code to do XYZ...\")\n\n# Custom template and 2 fixing rounds\nresult = AICodeFixer(lazy_call, [PT.UserMessage(\"Please fix the code.\n\nFeedback: {{feedback}}\")]; num_rounds = 2) |> run!\n\n# The result now contains the AI's attempts to fix the code\npreview(result.call.conversation)\n\nNotes\n\nAICodeFixer is particularly useful when code is hard to get right in one shot (eg, smaller models, complex syntax)\nThe structure leverages the lazy evaluation model of AICall (/AIGenerate) to efficiently manage AI interactions and be able to repeatedly call it.\nThe run! function executes the AI call and applies the feedback loop for the specified number of rounds, enabling an interactive code fixing process.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.RetryConfig","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.RetryConfig","text":"RetryConfig\n\nConfiguration for self-fixing the AI calls. It includes the following fields:\n\nFields\n\nretries::Int: The number of retries (\"fixing rounds\") that have been attempted so far.\ncalls::Int: The total number of SUCCESSFULLY generated ai* function calls made so far (across all samples/retry rounds). Ie, if a call fails, because of an API error, it's not counted, because it didn't reach the LLM.\nmax_retries::Int: The maximum number of retries (\"fixing rounds\") allowed for the AI call. Defaults to 10.\nmax_calls::Int: The maximum number of ai* function calls allowed for the AI call. Defaults to 99.\nretry_delay::Int: The delay (in seconds) between retry rounds. Defaults to 0s.\nn_samples::Int: The number of samples to generate in each ai* call round (to increase changes of successful pass). Defaults to 1.\nscoring::AbstractScoringMethod: The scoring method to use for generating multiple samples. Defaults to UCT(sqrt(2)).\nordering::Symbol: The ordering to use for select the best samples. With :PostOrderDFS we prioritize leaves, with :PreOrderDFS we prioritize the root. Defaults to :PostOrderDFS.\nfeedback_inplace::Bool: Whether to provide feedback in previous UserMessage (and remove the past AIMessage) or to create a new UserMessage. Defaults to false.\nfeedback_template::Symbol: Template to use for feedback in place. Defaults to :FeedbackFromEvaluator.\ntemperature::Float64: The temperature to use for sampling. Relevant only if not defined in api_kwargs provided. Defaults to 0.7.\ncatch_errors::Bool: Whether to catch errors during run! of AICall. Saves them in aicall.error. Defaults to false.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.SampleNode","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.SampleNode","text":"SampleNode{T}\n\nA node in the Monte Carlo Tree Search tree. \n\nIt's used to hold the data we're trying to optimize/discover (eg, a conversation), the scores from evaluation (wins, visits) and the results of the evaluations upon failure (feedback).\n\nFields\n\nid::UInt16: Unique identifier for the node\nparent::Union{SampleNode, Nothing}: Parent node that current node was built on\nchildren::Vector{SampleNode}: Children nodes\nwins::Int: Number of successful outcomes\nvisits::Int: Number of condition checks done (eg, losses are checks - wins)\ndata::T: eg, the conversation or some parameter to be optimized\nfeedback::String: Feedback from the evaluation, always a string! Defaults to empty string.\nsuccess::Union{Nothing, Bool}: Success of the generation and subsequent evaluations, proxy for whether it should be further evaluated. Defaults to nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.ThompsonSampling","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.ThompsonSampling","text":"ThompsonSampling <: AbstractScoringMethod\n\nImplements scoring and selection for Thompson Sampling method. See https://en.wikipedia.org/wiki/Thompson_sampling for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.UCT","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.UCT","text":"UCT <: AbstractScoringMethod\n\nImplements scoring and selection for UCT (Upper Confidence Bound for Trees) sampling method. See https://en.wikipedia.org/wiki/MonteCarlotreesearch#Explorationand_exploitation for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AIClassify-Tuple","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AIClassify","text":"AIClassify(args...; kwargs...)\n\nCreates a lazy instance of aiclassify. It is an instance of AICall with aiclassify as the function.\n\nUse exactly the same arguments and keyword arguments as aiclassify (see ?aiclassify for details).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AIEmbed-Tuple","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AIEmbed","text":"AIEmbed(args...; kwargs...)\n\nCreates a lazy instance of aiembed. It is an instance of AICall with aiembed as the function.\n\nUse exactly the same arguments and keyword arguments as aiembed (see ?aiembed for details).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AIExtract-Tuple","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AIExtract","text":"AIExtract(args...; kwargs...)\n\nCreates a lazy instance of aiextract. It is an instance of AICall with aiextract as the function.\n\nUse exactly the same arguments and keyword arguments as aiextract (see ?aiextract for details).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AIGenerate-Tuple","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AIGenerate","text":"AIGenerate(args...; kwargs...)\n\nCreates a lazy instance of aigenerate. It is an instance of AICall with aigenerate as the function.\n\nUse exactly the same arguments and keyword arguments as aigenerate (see ?aigenerate for details).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.AIScan-Tuple","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.AIScan","text":"AIScan(args...; kwargs...)\n\nCreates a lazy instance of aiscan. It is an instance of AICall with aiscan as the function.\n\nUse exactly the same arguments and keyword arguments as aiscan (see ?aiscan for details).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.add_feedback!-Tuple{AbstractVector{<:PromptingTools.AbstractMessage}, PromptingTools.Experimental.AgentTools.SampleNode}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.add_feedback!","text":"add_feedback!(\n    conversation::AbstractVector{<:PT.AbstractMessage}, sample::SampleNode; feedback_inplace::Bool = false,\n    feedback_template::Symbol = :FeedbackFromEvaluator)\n\nAdds formatted feedback to the conversation based on the sample node feedback (and its ancestors).\n\nArguments\n\nconversation::AbstractVector{<:PT.AbstractMessage}: The conversation to add the feedback to.\nsample::SampleNode: The sample node to extract the feedback from.\nfeedback_inplace::Bool=false: If true, it will add the feedback to the last user message inplace (and pop the last AIMessage). Otherwise, it will append the feedback as a new message.\nfeedback_template::Symbol=:FeedbackFromEvaluator: The template to use for the feedback message. It must be a valid AITemplate name.\n\nExample\n\nsample = SampleNode(; data = nothing, feedback = \"Feedback X\")\nconversation = [PT.UserMessage(\"I say hi!\"), PT.AIMessage(; content = \"I say hi!\")]\nconversation = AT.add_feedback!(conversation, sample)\nconversation[end].content == \"### Feedback from Evaluator\nFeedback X\n\"\n\nInplace feedback:\n\njulia conversation = [PT.UserMessage(\"I say hi!\"), PT.AIMessage(; content = \"I say hi!\")] conversation = AT.addfeedback!(conversation, sample; feedbackinplace = true) conversation[end].content == \"I say hi!\n\nFeedback from Evaluator\n\nFeedback X \"\n\n\nSample with ancestors with feedback:\n\njulia samplep = SampleNode(; data = nothing, feedback = \" Feedback X\") sample = expand!(samplep, nothing) sample.feedback = \" Feedback Y\" conversation = [PT.UserMessage(\"I say hi!\"), PT.AIMessage(; content = \"I say hi!\")] conversation = AT.add_feedback!(conversation, sample)\n\nconversation[end].content == \"### Feedback from Evaluator\n\nFeedback X\n\nFeedback Y \" ```\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.aicodefixer_feedback-Tuple{AbstractVector{<:PromptingTools.AbstractMessage}}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.aicodefixer_feedback","text":"aicodefixer_feedback(conversation::AbstractVector{<:PT.AbstractMessage}; max_length::Int = 512) -> NamedTuple(; feedback::String)\n\nGenerate feedback for an AI code fixing session based on the conversation history. Function is designed to be extensible for different types of feedback and code evaluation outcomes. \n\nThe highlevel wrapper accepts a conversation and returns new kwargs for the AICall.\n\nIndividual feedback functions are dispatched on different subtypes of AbstractCodeOutcome and can be extended/overwritten to provide more detailed feedback.\n\nSee also: AIGenerate, AICodeFixer\n\nArguments\n\nconversation::AbstractVector{<:PT.AbstractMessage}: A vector of messages representing the conversation history, where the last message is expected to contain the code to be analyzed.\nmax_length::Int=512: An optional argument that specifies the maximum length of the feedback message.\n\nReturns\n\nNamedTuple: A feedback message as a kwarg in NamedTuple based on the analysis of the code provided in the conversation.\n\nExample\n\nnew_kwargs = aicodefixer_feedback(conversation)\n\nNotes\n\nThis function is part of the AI code fixing system, intended to interact with code in AIMessage and provide feedback on improving it.\n\nThe highlevel wrapper accepts a conversation and returns new kwargs for the AICall.\n\nIt dispatches for the code feedback based on the subtypes of AbstractCodeOutcome below:\n\nCodeEmpty: No code found in the message.\nCodeFailedParse: Code parsing error.\nCodeFailedEval: Runtime evaluation error.\nCodeFailedTimeout: Code execution timed out.\nCodeSuccess: Successful code execution.\n\nYou can override the individual methods to customize the feedback.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.airetry!","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.airetry!","text":"airetry!(\n    f_cond::Function, aicall::AICallBlock, feedback::Union{AbstractString, Function} = \"\";\n    verbose::Bool = true, throw::Bool = false, evaluate_all::Bool = true, feedback_expensive::Bool = false,\n    max_retries::Union{Nothing, Int} = nothing, retry_delay::Union{Nothing, Int} = nothing)\n\nEvaluates the condition f_cond on the aicall object (eg, we evaluate f_cond(aicall) -> Bool).  If the condition is not met, it will return the best sample to retry from and provide feedback to aicall. That's why it's mutating. It will retry running the aicall max_retries times. If throw is true, it will throw an error if the function does not return true after max_retries retries.\n\nIf feedback is provided (not empty), it will be append it to the conversation before the retry.  If a function is provided, it must accept the aicall object as the only argument and return a string.\n\nFunction f_cond is expected to accept the aicall object as the only argument.  It must return a boolean value, which indicates whether the condition is met. You can leverage the last_message, last_output, and AICode functions to access the last message, last output and code blocks in the conversation, respectively.\n\nGood Use Cases\n\nRetry with API failures/drops (add retry_delay=2 to wait 2s between retries)\nCheck the output format / type / length / etc\nCheck the output with aiclassify call (LLM Judge) to catch unsafe/NSFW/out-of-scope content\nProvide hints to the model to guide it to the correct answer\n\nGotchas\n\nIf controlling keyword arguments are set to nothing, they will fall back to the default values in aicall.config. You can override them by passing the keyword arguments explicitly.\nIf there multiple airetry! checks, they are evaluted sequentially. As long as throw==false, they will be all evaluated even if they failed previous checks.\nOnly samples which passed previous evaluations are evaluated (sample.success is true). If there are no successful samples, the function will evaluate only the active sample (aicall.active_sample_id) and nothing else.\nFeedback from all \"ancestor\" evaluations is added upon retry, not feedback from the \"sibblings\" or other branches. To have only ONE long BRANCH (no sibblings), make sure to keep RetryConfig(; n_samples=1).  That way the model will always see ALL previous feedback.\nWe implement a version of Monte Carlo Tree Search (MCTS) to always pick the most promising sample to restart from (you can tweak the options in RetryConfig to change the behaviour).\nFor large number of parallel branches (ie, \"shallow and wide trees\"), you might benefit from switching scoring to scoring=ThompsonSampling() (similar to how Bandit algorithms work).\nOpen-source/local models can struggle with too long conversation, you might want to experiment with in-place feedback (set RetryConfig(; feedback_inplace=true)).\n\nArguments\n\nf_cond::Function: A function that accepts the aicall object and returns a boolean value. Retry will be attempted if the condition is not met (f_cond -> false).\naicall::AICallBlock: The aicall object to evaluate the condition on.\nfeedback::Union{AbstractString, Function}: Feedback to provide if the condition is not met. If a function is provided, it must accept the aicall object as the only argument and return a string.\nverbose::Integer=1: A verbosity level for logging the retry attempts and warnings. A higher value indicates more detailed logging.\nthrow::Bool=false: If true, it will throw an error if the function f_cond does not return true after max_retries retries.\nevaluate_all::Bool=false: If true, it will evaluate all the \"successful\" samples in the aicall object. Otherwise, it will only evaluate the active sample.\nfeedback_expensive::Bool=false: If false, it will provide feedback to all samples that fail the condition.  If feedback function is expensive to call (eg, another ai* function), set this to true and feedback will be provided only to the sample we will retry from.\nmax_retries::Union{Nothing, Int}=nothing: Maximum number of retries. If not provided, it will fall back to the max_retries in aicall.config.\nretry_delay::Union{Nothing, Int}=nothing: Delay between retries in seconds. If not provided, it will fall back to the retry_delay in aicall.config.\n\nReturns\n\nThe aicall object with the updated conversation, and samples (saves the evaluations and their scores/feedback).\n\nExample\n\nYou can use airetry! to catch API errors in run! and auto-retry the call.  RetryConfig is how you influence all the subsequent retry behaviours - see ?RetryConfig for more details.\n\n# API failure because of a non-existent model\nout = AIGenerate(\"say hi!\"; config = RetryConfig(; catch_errors = true),\n    model = \"NOTEXIST\")\nrun!(out) # fails\n\n# we ask to wait 2s between retries and retry 2 times (can be set in `config` in aicall as well)\nairetry!(isvalid, out; retry_delay = 2, max_retries = 2)\n\nIf you provide arguments to the aicall, we try to honor them as much as possible in the following calls,  eg, set low verbosity\n\nout = AIGenerate(\"say hi!\"; config = RetryConfig(; catch_errors = true),\nmodel = \"NOTEXIST\", verbose=false)\nrun!(out)\n# No info message, you just see `success = false` in the properties of the AICall\n\nLet's show a toy example to demonstrate the runtime checks / guardrails for the model output. We'll play a color guessing game (I'm thinking \"yellow\"):\n\n# Notice that we ask for two samples (`n_samples=2`) at each attempt (to improve our chances). \n# Both guesses are scored at each time step, and the best one is chosen for the next step.\n# And with OpenAI, we can set `api_kwargs = (;n=2)` to get both samples simultaneously (cheaper and faster)!\nout = AIGenerate(\n    \"Guess what color I'm thinking. It could be: blue, red, black, white, yellow. Answer with 1 word only\";\n    verbose = false,\n    config = RetryConfig(; n_samples = 2), api_kwargs = (; n = 2))\nrun!(out)\n\n## Check that the output is 1 word only, third argument is the feedback that will be provided if the condition fails\n## Notice: functions operate on `aicall` as the only argument. We can use utilities like `last_output` and `last_message` to access the last message and output in the conversation.\nairetry!(x -> length(split(last_output(x), r\" |\\.\")) == 1, out,\n    \"You must answer with 1 word only.\")\n\n## Let's ensure that the output is in lowercase - simple and short\nairetry!(x -> all(islowercase, last_output(x)), out, \"You must answer in lowercase.\")\n# [ Info: Condition not met. Retrying...\n\n## Let's add final hint - it took us 2 retries\nairetry!(x -> startswith(last_output(x), \"y\"), out, \"It starts with \"y\"\")\n# [ Info: Condition not met. Retrying...\n# [ Info: Condition not met. Retrying...\n\n## We end up with the correct answer\nlast_output(out)\n# Output: \"yellow\"\n\nLet's explore how we got here.  We save the various attempts in a \"tree\" (SampleNode object) You can access it in out.samples, which is the ROOT of the tree (top level). Currently \"active\" sample ID is out.active_sample_id -> that's the same as conversation field in your AICall.\n\n# Root node:\nout.samples\n# Output: SampleNode(id: 46839, stats: 6/12, length: 2)\n\n# Active sample (our correct answer):\nout.active_sample_id \n# Output: 50086\n\n# Let's obtain the active sample node with this ID  - use getindex notation or function find_node\nout.samples[out.active_sample_id]\n# Output: SampleNode(id: 50086, stats: 1/1, length: 7)\n\n# The SampleNode has two key fields: data and feedback. Data is where the conversation is stored:\nactive_sample = out.samples[out.active_sample_id]\nactive_sample.data == out.conversation # Output: true -> This is the winning guess!\n\nWe also get a clear view of the tree structure of all samples with print_samples:\n\njulia> print_samples(out.samples)\nSampleNode(id: 46839, stats: 6/12, score: 0.5, length: 2)\n├─ SampleNode(id: 12940, stats: 5/8, score: 1.41, length: 4)\n│  ├─ SampleNode(id: 34315, stats: 3/4, score: 1.77, length: 6)\n│  │  ├─ SampleNode(id: 20493, stats: 1/1, score: 2.67, length: 7)\n│  │  └─ SampleNode(id: 50086, stats: 1/1, score: 2.67, length: 7)\n│  └─ SampleNode(id: 2733, stats: 1/2, score: 1.94, length: 5)\n└─ SampleNode(id: 48343, stats: 1/4, score: 1.36, length: 4)\n   ├─ SampleNode(id: 30088, stats: 0/1, score: 1.67, length: 5)\n   └─ SampleNode(id: 44816, stats: 0/1, score: 1.67, length: 5)\n\nYou can use the id to grab and inspect any of these nodes, eg,\n\nout.samples[2733]\n# Output: SampleNode(id: 2733, stats: 1/2, length: 5)\n\nWe can also iterate through all samples and extract whatever information we want with PostOrderDFS or PreOrderDFS (exported from AbstractTrees.jl)\n\nfor sample in PostOrderDFS(out.samples)\n    # Data is the universal field for samples, we put `conversation` in there\n    # Last item in data is the last message in coversation\n    msg = sample.data[end]\n    if msg isa PT.AIMessage # skip feedback\n        # get only the message content, ie, the guess\n        println(\"ID: $(sample.id), Answer: $(msg.content)\")\n    end\nend\n\n# ID: 20493, Answer: yellow\n# ID: 50086, Answer: yellow\n# ID: 2733, Answer: red\n# ID: 30088, Answer: blue\n# ID: 44816, Answer: blue\n\nNote: airetry! will attempt to fix the model max_retries times.  If you set throw=true, it will throw an ErrorException if the condition is not met after max_retries retries.\n\n# Let's define a mini program to guess the number\n\"\"\"\n    llm_guesser()\n\nMini program to guess the number provided by the user (betwee 1-100).\n\"\"\"\nfunction llm_guesser(user_number::Int)\n    @assert 1 <= user_number <= 100\n    prompt = \"\"\"\nI'm thinking a number between 1-100. Guess which one it is. \nYou must respond only with digits and nothing else. \nYour guess:\"\"\"\n    ## 2 samples at a time, max 5 fixing rounds\n    out = AIGenerate(prompt; config = RetryConfig(; n_samples = 2, max_retries = 5),\n        api_kwargs = (; n = 2)) |> run!\n    ## Check the proper output format - must parse to Int, use do-syntax\n    ## We can provide feedback via a function!\n    function feedback_f(aicall)\n        \"Output: $(last_output(aicall))\nFeedback: You must respond only with digits!!\"\n    end\n    airetry!(out, feedback_f) do aicall\n        !isnothing(tryparse(Int, last_output(aicall)))\n    end\n    ## Give a hint on bounds\n    lower_bound = (user_number ÷ 10) * 10\n    upper_bound = lower_bound + 10\n    airetry!(\n        out, \"The number is between or equal to $lower_bound to $upper_bound.\") do aicall\n        guess = tryparse(Int, last_output(aicall))\n        lower_bound <= guess <= upper_bound\n    end\n    ## You can make at most 3x guess now -- if there is max_retries in `config.max_retries` left\n    max_retries = out.config.retries + 3\n    function feedback_f2(aicall)\n        guess = tryparse(Int, last_output(aicall))\n        \"Your guess of $(guess) is wrong, it's $(abs(guess-user_number)) numbers away.\"\n    end\n    airetry!(out, feedback_f2; max_retries) do aicall\n        tryparse(Int, last_output(aicall)) == user_number\n    end\n\n    ## Evaluate the best guess\n    @info \"Results: Guess: $(last_output(out)) vs User: $user_number (Number of calls made: $(out.config.calls))\"\n    return out\nend\n\n# Let's play the game\nout = llm_guesser(33)\n[ Info: Condition not met. Retrying...\n[ Info: Condition not met. Retrying...\n[ Info: Condition not met. Retrying...\n[ Info: Condition not met. Retrying...\n[ Info: Results: Guess: 33 vs User: 33 (Number of calls made: 10)\n\nYay! We got it :)\n\nNow, we could explore different samples (eg, print_samples(out.samples)) or see what the model guessed at each step:\n\nprint_samples(out.samples)\n## SampleNode(id: 57694, stats: 6/14, score: 0.43, length: 2)\n## ├─ SampleNode(id: 35603, stats: 5/10, score: 1.23, length: 4)\n## │  ├─ SampleNode(id: 55394, stats: 1/4, score: 1.32, length: 6)\n## │  │  ├─ SampleNode(id: 20737, stats: 0/1, score: 1.67, length: 7)\n## │  │  └─ SampleNode(id: 52910, stats: 0/1, score: 1.67, length: 7)\n## │  └─ SampleNode(id: 43094, stats: 3/4, score: 1.82, length: 6)\n## │     ├─ SampleNode(id: 14966, stats: 1/1, score: 2.67, length: 7)\n## │     └─ SampleNode(id: 32991, stats: 1/1, score: 2.67, length: 7)\n## └─ SampleNode(id: 20506, stats: 1/4, score: 1.4, length: 4)\n##    ├─ SampleNode(id: 37581, stats: 0/1, score: 1.67, length: 5)\n##    └─ SampleNode(id: 46632, stats: 0/1, score: 1.67, length: 5)\n\n# Lastly, let's check all the guesses AI made across all samples. \n# Our winning guess was ID 32991 (`out.active_sample_id`)\n\nfor sample in PostOrderDFS(out.samples)\n    [println(\"ID: $(sample.id), Guess: $(msg.content)\")\n     for msg in sample.data if msg isa PT.AIMessage]\nend\n## ID: 20737, Guess: 50\n## ID: 20737, Guess: 35\n## ID: 20737, Guess: 37\n## ID: 52910, Guess: 50\n## ID: 52910, Guess: 35\n## ID: 52910, Guess: 32\n## ID: 14966, Guess: 50\n## ID: 14966, Guess: 35\n## ID: 14966, Guess: 33\n## ID: 32991, Guess: 50\n## ID: 32991, Guess: 35\n## ID: 32991, Guess: 33\n## etc...\n\nNote that if there are multiple \"branches\" the model will see only the feedback of its own and its ancestors not the other \"branches\".  If you want to show all object, set n_samples=1, so all fixing happens sequantially and model sees all feedback (less powerful if model falls into a bad state). Alternatively, you can tweak the feedback function.\n\nSee Also\n\nReferences: airetry is inspired by the Language Agent Tree Search paper and by DSPy Assertions paper.\n\n\n\n\n\n","category":"function"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.backpropagate!-Tuple{PromptingTools.Experimental.AgentTools.SampleNode}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.backpropagate!","text":"Provides scores for a given node (and all its ancestors) based on the evaluation (wins, visits).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.beta_sample-Tuple{Real, Real}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.beta_sample","text":"beta_sample(α::Real, β::Real)\n\nApproximates a sample from the Beta distribution by generating two independent Gamma distributed samples and using their ratio.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.collect_all_feedback-Tuple{PromptingTools.Experimental.AgentTools.SampleNode}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.collect_all_feedback","text":"Collects all feedback from the node and its ancestors (parents). Returns a string separated by separator.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.evaluate_condition!","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.evaluate_condition!","text":"evaluate_condition!(f_cond::Function, aicall::AICallBlock,\n    feedback::Union{AbstractString, Function} = \"\";\n    evaluate_all::Bool = true, feedback_expensive::Bool = false)\n\nEvalutes the condition f_cond (must return Bool) on the aicall object.  If the condition is not met, it will return the best sample to retry from and provide feedback.\n\nMutating as the results are saved in aicall.samples\n\nIf evaluate_all is true, it will evaluate all the \"successful\" samples in the aicall object. Otherwise, it will only evaluate the active sample..\n\nFor f_cond and feedback functions, you can use the last_message and last_output utilities to access the last message and last output in the conversation, respectively.\n\nArguments\n\nf_cond::Function: A function that accepts the aicall object and returns a boolean value. Retry will be attempted if the condition is not met (f_cond -> false).\naicall::AICallBlock: The aicall object to evaluate the condition on.\nfeedback::Union{AbstractString, Function}: Feedback to provide if the condition is not met. If a function is provided, it must accept the aicall object as the only argument and return a string.\nevaluate_all::Bool=false: If true, it will evaluate all the \"successful\" samples in the aicall object. Otherwise, it will only evaluate the active sample.\nfeedback_expensive::Bool=false: If false, it will provide feedback to all samples that fail the condition.  If feedback function is expensive to call (eg, another ai* function), set this to true and feedback will be provided only to the sample we will retry from.\n\nReturns\n\na tuple (condition_passed, sample), where condition_passed is a boolean indicating whether the condition was met, and sample is the best sample to retry from.\n\nExample\n\n# Mimic AIGenerate run!\naicall = AIGenerate(\"Say hi!\"; config = RetryConfig(; n_samples = 2))\nsample = expand!(aicall.samples, aicall.conversation; success = true)\naicall.active_sample_id = sample.id\n\n# Return whether it passed and node to take the next action from\ncond, node = AT.evaluate_condition!(x -> occursin(\"hi\", last_output(x)), aicall)\n\n# Checks:\ncond == true\nnode == sample\nnode.wins == 1\n\nWith feedback: ```julia\n\nMimic AIGenerate run with feedback\n\naicall = AIGenerate(     :BlankSystemUser; system = \"a\", user = \"b\") sample = expand!(aicall.samples, aicall.conversation; success = true) aicall.activesampleid = sample.id\n\nEvaluate\n\ncond, node = AT.evaluatecondition!(     x -> occursin(\"NOTFOUND\", lastoutput(x)), aicall, \"Feedback X\") cond == false # fail sample == node # same node (no other choice) node.wins == 0 node.feedback == \" Feedback X\"\n\n\n\n\n\n","category":"function"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.expand!-Tuple{PromptingTools.Experimental.AgentTools.SampleNode, Any}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.expand!","text":"Expands the tree with a new node from parent using the given data and success.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.extract_config-Union{Tuple{T}, Tuple{Any, T}} where T","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.extract_config","text":"Extracts config::RetryConfig from kwargs and returns the rest of the kwargs.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.find_node-Tuple{PromptingTools.Experimental.AgentTools.SampleNode, Integer}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.find_node","text":"Finds a node with a given id in the tree starting from node.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.gamma_sample-Tuple{Real, Real}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.gamma_sample","text":"gamma_sample(α::Real, θ::Real)\n\nApproximates a sample from the Gamma distribution using the Marsaglia and Tsang method.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.last_message-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.last_message","text":"Helpful accessor for AICall blocks. Returns the last message in the conversation.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.last_output-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.last_output","text":"Helpful accessor for AICall blocks. Returns the last output in the conversation (eg, the string/data in the last message).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.print_samples-Tuple{PromptingTools.Experimental.AgentTools.SampleNode}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.print_samples","text":"Pretty prints the samples tree starting from node. Usually, node is the root of the tree. Example: print_samples(aicall.samples).\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.remove_used_kwargs-Tuple{NamedTuple, AbstractVector{<:PromptingTools.AbstractMessage}}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.remove_used_kwargs","text":"Removes the kwargs that have already been used in the conversation. Returns NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.reset_success!","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.reset_success!","text":"Sets the success field of all nodes in the tree to success value.\n\n\n\n\n\n","category":"function"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.run!-Tuple{AICodeFixer}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.run!","text":"run!(codefixer::AICodeFixer; verbose::Int = 1, max_conversation_length::Int = 32000, run_kwargs...)\n\nExecutes the code fixing process encapsulated by the AICodeFixer instance.  This method iteratively refines and fixes code by running the AI call in a loop for a specified number of rounds, using feedback from the code evaluation (aicodefixer_feedback) to improve the outcome in each iteration.\n\nArguments\n\ncodefixer::AICodeFixer: An instance of AICodeFixer containing the AI call, templates, and settings for the code fixing session.\nverbose::Int=1: Verbosity level for logging. A higher value indicates more detailed logging.\nmax_conversation_length::Int=32000: Maximum length in characters for the conversation history to keep it within manageable limits, especially for large code fixing sessions.\nnum_rounds::Union{Nothing, Int}=nothing: Number of additional rounds for the code fixing session. If nothing, the value from the AICodeFixer instance is used.\nrun_kwargs...: Additional keyword arguments that are passed to the AI function.\n\nReturns\n\nAICodeFixer: The updated AICodeFixer instance with the results of the code fixing session.\n\nUsage\n\naicall = AICall(aigenerate, schema=mySchema, conversation=myConversation)\ncodefixer = AICodeFixer(aicall, myTemplates; num_rounds=5)\nresult = run!(codefixer, verbose=2)\n\nNotes\n\nThe run! method drives the core logic of the AICodeFixer, iterating through rounds of AI interactions to refine and fix code.\nIn each round, it applies feedback based on the current state of the conversation, allowing the AI to respond more effectively.\nThe conversation history is managed to ensure it stays within the specified max_conversation_length, keeping the AI's focus on relevant parts of the conversation.\nThis iterative process is essential for complex code fixing tasks where multiple interactions and refinements are required to achieve the desired outcome.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.run!-Tuple{PromptingTools.Experimental.AgentTools.AICallBlock}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.run!","text":"run!(aicall::AICallBlock; verbose::Int = 1, catch_errors::Bool = false, return_all::Bool = true, kwargs...)\n\nExecutes the AI call wrapped by an AICallBlock instance. This method triggers the actual communication with the AI model and processes the response based on the provided conversation context and parameters.\n\nNote: Currently return_all must always be set to true.\n\nArguments\n\naicall::AICallBlock: An instance of AICallBlock which encapsulates the AI function call along with its context and parameters (eg, AICall, AIGenerate)\nverbose::Integer=1: A verbosity level for logging. A higher value indicates more detailed logging.\ncatch_errors::Union{Nothing, Bool}=nothing: A flag to indicate whether errors should be caught and saved to aicall.error. If nothing, it defaults to aicall.config.catch_errors.\nreturn_all::Bool=true: A flag to indicate whether the whole conversation from the AI call should be returned. It should always be true.\nkwargs...: Additional keyword arguments that are passed to the AI function.\n\nReturns\n\nAICallBlock: The same AICallBlock instance, updated with the results of the AI call. This includes updated conversation, success status, and potential error information.\n\nExample\n\naicall = AICall(aigenerate)\nrun!(aicall)\n\nAlternatively, you can trigger the run! call by using the AICall as a functor and calling it with a string or a UserMessage:\n\naicall = AICall(aigenerate)\naicall(\"Say hi!\")\n\nNotes\n\nThe run! method is a key component of the lazy evaluation model in AICall. It allows for the deferred execution of AI function calls, providing flexibility in how and when AI interactions are conducted.\nThe method updates the AICallBlock instance with the outcome of the AI call, including any generated responses, success or failure status, and error information if an error occurred.\nThis method is essential for scenarios where AI interactions are based on dynamic or evolving contexts, as it allows for real-time updates and responses based on the latest information.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.score-Tuple{PromptingTools.Experimental.AgentTools.SampleNode, PromptingTools.Experimental.AgentTools.ThompsonSampling}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.score","text":"Scores a node using the ThomsonSampling method, similar to Bandit algorithms.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.score-Tuple{PromptingTools.Experimental.AgentTools.SampleNode, PromptingTools.Experimental.AgentTools.UCT}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.score","text":"Scores a node using the UCT (Upper Confidence Bound for Trees) method.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.select_best","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.select_best","text":"select_best(node::SampleNode, scoring::AbstractScoringMethod = UCT();\n    ordering::Symbol = :PostOrderDFS)\n\nSelects the best node from the tree using the given scoring (UCT or ThompsonSampling). Defaults to UCT. Thompson Sampling is more random with small samples, while UCT stabilizes much quicker thanks to looking at parent nodes as well.\n\nOrdering can be either :PreOrderDFS or :PostOrderDFS. Defaults to :PostOrderDFS, which favors the leaves (end points of the tree).\n\nExample\n\nCompare the different scoring methods:\n\n# Set up mock samples and scores\ndata = PT.AbstractMessage[]\nroot = SampleNode(; data)\nchild1 = expand!(root, data)\nbackpropagate!(child1; wins = 1, visits = 1)\nchild2 = expand!(root, data)\nbackpropagate!(child2; wins = 0, visits = 1)\nchild11 = expand!(child1, data)\nbackpropagate!(child11; wins = 1, visits = 1)\n\n# Select with UCT\nn = select_best(root, UCT())\nSampleNode(id: 29826, stats: 1/1, length: 0)\n\n# Show the tree:\nprint_samples(root; scoring = UCT())\n## SampleNode(id: 13184, stats: 2/3, score: 0.67, length: 0)\n## ├─ SampleNode(id: 26078, stats: 2/2, score: 2.05, length: 0)\n## │  └─ SampleNode(id: 29826, stats: 1/1, score: 2.18, length: 0)\n## └─ SampleNode(id: 39931, stats: 0/1, score: 1.48, length: 0)\n\n# Select with ThompsonSampling - much more random with small samples\nn = select_best(root, ThompsonSampling())\nSampleNode(id: 26078, stats: 2/2, length: 0)\n\n# Show the tree (run it a few times and see how the scores jump around):\nprint_samples(root; scoring = ThompsonSampling())\n## SampleNode(id: 13184, stats: 2/3, score: 0.6, length: 0)\n## ├─ SampleNode(id: 26078, stats: 2/2, score: 0.93, length: 0)\n## │  └─ SampleNode(id: 29826, stats: 1/1, score: 0.22, length: 0)\n## └─ SampleNode(id: 39931, stats: 0/1, score: 0.84, length: 0)\n\n\n\n\n\n\n","category":"function"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.split_multi_samples-Tuple{Any}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.split_multi_samples","text":"If the conversation has multiple AIMessage samples, split them into separate conversations with the common past.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.truncate_conversation-Tuple{AbstractVector{<:PromptingTools.AbstractMessage}}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.truncate_conversation","text":"truncate_conversation(conversation::AbstractVector{<:PT.AbstractMessage};\n    max_conversation_length::Int = 32000)\n\nTruncates a given conversation to a max_conversation_length characters by removing messages \"in the middle\". It tries to retain the original system+user message and also the most recent messages.\n\nPractically, if a conversation is too long, it will start by removing the most recent message EXCEPT for the last two (assumed to be the last AIMessage with the code and UserMessage with the feedback\n\nArguments\n\nmax_conversation_length is in characters; assume c. 2-3 characters per LLM token, so 32000 should correspond to 16K context window.\n\n\n\n\n\n","category":"method"},{"location":"reference_agenttools/#PromptingTools.Experimental.AgentTools.unwrap_aicall_args-Tuple{Any}","page":"AgentTools","title":"PromptingTools.Experimental.AgentTools.unwrap_aicall_args","text":"Unwraps the arguments for AICall and returns the schema and conversation (if provided). Expands any provided AITemplate.\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#Reference-for-RAGTools","page":"RAGTools","title":"Reference for RAGTools","text":"","category":"section"},{"location":"reference_ragtools/","page":"RAGTools","title":"RAGTools","text":"Modules = [PromptingTools.Experimental.RAGTools]","category":"page"},{"location":"reference_ragtools/","page":"RAGTools","title":"RAGTools","text":"Modules = [PromptingTools.Experimental.RAGTools]","category":"page"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools","text":"RAGTools\n\nProvides Retrieval-Augmented Generation (RAG) functionality.\n\nRequires: LinearAlgebra, SparseArrays, PromptingTools for proper functionality.\n\nThis module is experimental and may change at any time. It is intended to be moved to a separate package in the future.\n\n\n\n\n\n","category":"module"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.ChunkIndex","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.ChunkIndex","text":"ChunkIndex\n\nMain struct for storing document chunks and their embeddings. It also stores tags and sources for each chunk.\n\nFields\n\nid::Symbol: unique identifier of each index (to ensure we're using the right index with CandidateChunks)\nchunks::Vector{<:AbstractString}: underlying document chunks / snippets\nembeddings::Union{Nothing, Matrix{<:Real}}: for semantic search\ntags::Union{Nothing, AbstractMatrix{<:Bool}}: for exact search, filtering, etc. This is often a sparse matrix indicating which chunks have the given tag (see tag_vocab for the position lookup)\ntags_vocab::Union{Nothing, Vector{<:AbstractString}}: vocabulary for the tags matrix (each column in tags is one item in tags_vocab and rows are the chunks)\nsources::Vector{<:AbstractString}: sources of the chunks\nextras::Union{Nothing, AbstractVector}: additional data, eg, metadata, source code, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.JudgeAllScores","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.JudgeAllScores","text":"final_rating is the average of all scoring criteria. Explain the final_rating in rationale\n\n\n\n\n\n","category":"type"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.JudgeRating","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.JudgeRating","text":"Provide the final_rating between 1-5. Provide the rationale for it.\n\n\n\n\n\n","category":"type"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.MultiIndex","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.MultiIndex","text":"Composite index that stores multiple ChunkIndex objects and their embeddings\n\n\n\n\n\n","category":"type"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.RAGContext","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.RAGContext","text":"RAGContext\n\nA struct for debugging RAG answers. It contains the question, answer, context, and the candidate chunks at each step of the RAG pipeline.\n\n\n\n\n\n","category":"type"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools._normalize","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools._normalize","text":"Shortcut to LinearAlgebra.normalize. Provided in the package extension RAGToolsExperimentalExt (Requires SparseArrays and LinearAlgebra)\n\n\n\n\n\n","category":"function"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.airag","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.airag","text":"airag(index::AbstractChunkIndex, rag_template::Symbol = :RAGAnswerFromContext;\n    question::AbstractString,\n    top_k::Int = 100, top_n::Int = 5, minimum_similarity::AbstractFloat = -1.0,\n    tag_filter::Union{Symbol, Vector{String}, Regex, Nothing} = :auto,\n    rerank_strategy::RerankingStrategy = Passthrough(),\n    model_embedding::String = PT.MODEL_EMBEDDING, model_chat::String = PT.MODEL_CHAT,\n    model_metadata::String = PT.MODEL_CHAT,\n    metadata_template::Symbol = :RAGExtractMetadataShort,\n    chunks_window_margin::Tuple{Int, Int} = (1, 1),\n    return_context::Bool = false, verbose::Bool = true,\n    rerank_kwargs::NamedTuple = NamedTuple(),\n    api_kwargs::NamedTuple = NamedTuple(),\n    aiembed_kwargs::NamedTuple = NamedTuple(),\n    aigenerate_kwargs::NamedTuple = NamedTuple(),\n    aiextract_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nGenerates a response for a given question using a Retrieval-Augmented Generation (RAG) approach. \n\nThe function selects relevant chunks from an ChunkIndex, optionally filters them based on metadata tags, reranks them, and then uses these chunks to construct a context for generating a response.\n\nArguments\n\nindex::AbstractChunkIndex: The chunk index to search for relevant text.\nrag_template::Symbol: Template for the RAG model, defaults to :RAGAnswerFromContext.\nquestion::AbstractString: The question to be answered.\ntop_k::Int: Number of top candidates to retrieve based on embedding similarity.\ntop_n::Int: Number of candidates to return after reranking.\nminimum_similarity::AbstractFloat: Minimum similarity threshold (between -1 and 1) for filtering chunks based on embedding similarity. Defaults to -1.0.\ntag_filter::Union{Symbol, Vector{String}, Regex}: Mechanism for filtering chunks based on tags (either automatically detected, specific tags, or a regex pattern). Disabled by setting to nothing.\nrerank_strategy::RerankingStrategy: Strategy for reranking the retrieved chunks. Defaults to Passthrough(). Use CohereRerank for better results (requires COHERE_API_KEY to be set)\nmodel_embedding::String: Model used for embedding the question, default is PT.MODEL_EMBEDDING.\nmodel_chat::String: Model used for generating the final response, default is PT.MODEL_CHAT.\nmodel_metadata::String: Model used for extracting metadata, default is PT.MODEL_CHAT.\nmetadata_template::Symbol: Template for the metadata extraction process from the question, defaults to: :RAGExtractMetadataShort\nchunks_window_margin::Tuple{Int,Int}: The window size around each chunk to consider for context building. See ?build_context for more information.\nreturn_context::Bool: If true, returns the context used for RAG along with the response.\nverbose::Bool: If true, enables verbose logging.\napi_kwargs: API parameters that will be forwarded to ALL of the API calls (aiembed, aigenerate, and aiextract).\naiembed_kwargs: API parameters that will be forwarded to the aiembed call. If you need to provide api_kwargs only to this function, simply add them as a keyword argument, eg, aiembed_kwargs = (; api_kwargs = (; x=1)).\naigenerate_kwargs: API parameters that will be forwarded to the aigenerate call. If you need to provide api_kwargs only to this function, simply add them as a keyword argument, eg, aigenerate_kwargs = (; api_kwargs = (; temperature=0.3)).\naiextract_kwargs: API parameters that will be forwarded to the aiextract call for the metadata extraction.\n\nReturns\n\nIf return_context is false, returns the generated message (msg).\nIf return_context is true, returns a tuple of the generated message (msg) and the RAG context (rag_context).\n\nNotes\n\nThe function first finds the closest chunks to the question embedding, then optionally filters these based on tags. After that, it reranks the candidates and builds a context for the RAG model.\nThe tag_filter can be used to refine the search. If set to :auto, it attempts to automatically determine relevant tags (if index has them available).\nThe chunks_window_margin allows including surrounding chunks for richer context, considering they are from the same source.\nThe function currently supports only single ChunkIndex. \n\nExamples\n\nUsing airag to get a response for a question:\n\nindex = build_index(...)  # create an index\nquestion = \"How to make a barplot in Makie.jl?\"\nmsg = airag(index, :RAGAnswerFromContext; question)\n\n# or simply\nmsg = airag(index; question)\n\nSee also build_index, build_context, CandidateChunks, find_closest, find_tags, rerank\n\n\n\n\n\n","category":"function"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.build_context-Tuple{PromptingTools.Experimental.RAGTools.AbstractChunkIndex, CandidateChunks}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.build_context","text":"build_context(index::AbstractChunkIndex, reranked_candidates::CandidateChunks; chunks_window_margin::Tuple{Int, Int}) -> Vector{String}\n\nBuild context strings for each position in reranked_candidates considering a window margin around each position.\n\nArguments\n\nreranked_candidates::CandidateChunks: Candidate chunks which contain positions to extract context from.\nindex::ChunkIndex: The index containing chunks and sources.\nchunks_window_margin::Tuple{Int, Int}: A tuple indicating the margin (before, after) around each position to include in the context.  Defaults to (1,1), which means 1 preceding and 1 suceeding chunk will be included. With (0,0), only the matching chunks will be included.\n\nReturns\n\nVector{String}: A vector of context strings, each corresponding to a position in reranked_candidates.\n\nExamples\n\nindex = ChunkIndex(...)  # Assuming a proper index is defined\ncandidates = CandidateChunks(index.id, [2, 4], [0.1, 0.2])\ncontext = build_context(index, candidates; chunks_window_margin=(0, 1)) # include only one following chunk for each matching chunk\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.build_index","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.build_index","text":"Build an index for RAG (Retriever-Augmented Generation) applications. REQUIRES SparseArrays and LinearAlgebra packages to be loaded!!\n\n\n\n\n\n","category":"function"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.build_index-Tuple{Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.build_index","text":"build_index(files_or_docs::Vector{<:AbstractString}; reader::Symbol = :files,\n    separators = [\"\\n\\n\", \". \", \"\\n\"], max_length::Int = 256,\n    sources::Vector{<:AbstractString} = files_or_docs,\n    extras::Union{Nothing, AbstractVector} = nothing,\n    extract_metadata::Bool = false, verbose::Integer = 1,\n    index_id = gensym(\"ChunkIndex\"),\n    metadata_template::Symbol = :RAGExtractMetadataShort,\n    model_embedding::String = PT.MODEL_EMBEDDING,\n    model_metadata::String = PT.MODEL_CHAT,\n    embedding_kwargs::NamedTuple = NamedTuple(),\n    metadata_kwargs::NamedTuple = NamedTuple(),\n    api_kwargs::NamedTuple = NamedTuple(),\n    cost_tracker = Threads.Atomic{Float64}(0.0))\n\nBuild an index for RAG (Retriever-Augmented Generation) applications from the provided file paths.  The function processes each file, splits its content into chunks, embeds these chunks,  optionally extracts metadata, and then compiles this information into a retrievable index.\n\nArguments\n\nfiles_or_docs: A vector of valid file paths OR string documents to be indexed (chunked and embedded).\nreader: A symbol indicating the type of input, can be either :files or :docs. Default is :files.\nseparators: A list of strings used as separators for splitting the text in each file into chunks. Default is [\\n\\n, \". \", \"\\n\"].\nmax_length: The maximum length of each chunk (if possible with provided separators). Default is 256.\nsources: A vector of strings indicating the source of each chunk. Default is equal to files_or_docs (for reader=:files)\nextras: An optional vector of extra information to be stored with each chunk. Default is nothing.\nextract_metadata: A boolean flag indicating whether to extract metadata from each chunk (to build filter tags in the index). Default is false. Metadata extraction incurs additional cost and requires model_metadata and metadata_template to be provided.\nverbose: An Integer specifying the verbosity of the logs. Default is 1 (high-level logging). 0 is disabled.\nmetadata_template: A symbol indicating the template to be used for metadata extraction. Default is :RAGExtractMetadataShort.\nmodel_embedding: The model to use for embedding.\nmodel_metadata: The model to use for metadata extraction.\napi_kwargs: Parameters to be provided to the API endpoint. Shared across all API calls.\nembedding_kwargs: Parameters to be provided to the get_embedding function. Useful to change the batch sizes (target_batch_size_length) or reduce asyncmap tasks (ntasks).\nmetadata_kwargs: Parameters to be provided to the get_metadata function.\n\nReturns\n\nChunkIndex: An object containing the compiled index of chunks, embeddings, tags, vocabulary, and sources.\n\nSee also: MultiIndex, CandidateChunks, find_closest, find_tags, rerank, airag\n\nExamples\n\n# Assuming `test_files` is a vector of file paths\nindex = build_index(test_files; max_length=10, extract_metadata=true)\n\n# Another example with metadata extraction and verbose output (`reader=:files` is implicit)\nindex = build_index([\"file1.txt\", \"file2.txt\"]; \n                    separators=[\". \"], \n                    extract_metadata=true, \n                    verbose=true)\n\nNotes\n\nIf you get errors about exceeding embedding input sizes, first check the max_length in your chunks.  If that does NOT resolve the issue, try changing the embedding_kwargs.  In particular, reducing the target_batch_size_length parameter (eg, 10_000) and number of tasks ntasks=1.  Some providers cannot handle large batch sizes (eg, Databricks).\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.build_qa_evals-Tuple{Vector{<:AbstractString}, Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.build_qa_evals","text":"build_qa_evals(doc_chunks::Vector{<:AbstractString}, sources::Vector{<:AbstractString};\n               model=PT.MODEL_CHAT, instructions=\"None.\", qa_template::Symbol=:RAGCreateQAFromContext, \n               verbose::Bool=true, api_kwargs::NamedTuple = NamedTuple(), kwargs...) -> Vector{QAEvalItem}\n\nCreate a collection of question and answer evaluations (QAEvalItem) from document chunks and sources.  This function generates Q&A pairs based on the provided document chunks, using a specified AI model and template.\n\nArguments\n\ndoc_chunks::Vector{<:AbstractString}: A vector of document chunks, each representing a segment of text.\nsources::Vector{<:AbstractString}: A vector of source identifiers corresponding to each chunk in doc_chunks (eg, filenames or paths).\nmodel: The AI model used for generating Q&A pairs. Default is PT.MODEL_CHAT.\ninstructions::String: Additional instructions or context to provide to the model generating QA sets. Defaults to \"None.\".\nqa_template::Symbol: A template symbol that dictates the AITemplate that will be used. It must have placeholder context. Default is :CreateQAFromContext.\napi_kwargs::NamedTuple: Parameters that will be forwarded to the API endpoint.\nverbose::Bool: If true, additional information like costs will be logged. Defaults to true.\n\nReturns\n\nVector{QAEvalItem}: A vector of QAEvalItem structs, each containing a source, context, question, and answer. Invalid or empty items are filtered out.\n\nNotes\n\nThe function internally uses aiextract to generate Q&A pairs based on the provided qa_template. So you can use any kwargs that you want.\nEach QAEvalItem includes the context (document chunk), the generated question and answer, and the source.\nThe function tracks and reports the cost of AI calls if verbose is enabled.\nItems where the question, answer, or context is empty are considered invalid and are filtered out.\n\nExamples\n\nCreating Q&A evaluations from a set of document chunks:\n\ndoc_chunks = [\"Text from document 1\", \"Text from document 2\"]\nsources = [\"source1\", \"source2\"]\nqa_evals = build_qa_evals(doc_chunks, sources)\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.build_tags","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.build_tags","text":"Builds a matrix of tags and a vocabulary list. REQUIRES SparseArrays and LinearAlgebra packages to be loaded!!\n\n\n\n\n\n","category":"function"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.cohere_api-Tuple{}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.cohere_api","text":"cohere_api(;\napi_key::AbstractString,\nendpoint::String,\nurl::AbstractString=\"https://api.cohere.ai/v1\",\nhttp_kwargs::NamedTuple=NamedTuple(),\nkwargs...)\n\nLightweight wrapper around the Cohere API. See https://cohere.com/docs for more details.\n\nArguments\n\napi_key: Your Cohere API key. You can get one from https://dashboard.cohere.com/welcome/register (trial access is for free).\nendpoint: The Cohere endpoint to call. \nurl: The base URL for the Cohere API. Default is https://api.cohere.ai/v1.\nhttp_kwargs: Any additional keyword arguments to pass to HTTP.post.\nkwargs: Any additional keyword arguments to pass to the Cohere API.\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.find_closest-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.find_closest","text":"find_closest(emb::AbstractMatrix{<:Real},\n    query_emb::AbstractVector{<:Real};\n    top_k::Int = 100, minimum_similarity::AbstractFloat = -1.0)\n\nFinds the indices of chunks (represented by embeddings in emb) that are closest (cosine similarity) to query embedding (query_emb). \n\nIf minimum_similarity is provided, only indices with similarity greater than or equal to it are returned.  Similarity can be between -1 and 1 (-1 = completely opposite, 1 = exactly the same).\n\nReturns only top_k closest indices.\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.get_chunks-Tuple{Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.get_chunks","text":"get_chunks(files_or_docs::Vector{<:AbstractString}; reader::Symbol = :files,\n    sources::Vector{<:AbstractString} = files_or_docs,\n    verbose::Bool = true,\n    separators = [\"\\n\\n\", \". \", \"\\n\"], max_length::Int = 256)\n\nChunks the provided files_or_docs into chunks of maximum length max_length (if possible with provided separators).\n\nSupports two modes of operation:\n\nreader=:files: The function opens each file in files_or_docs and reads its content.\nreader=:docs: The function assumes that files_or_docs is a vector of strings to be chunked.\n\nArguments\n\nfiles_or_docs: A vector of valid file paths OR string documents to be chunked.\nreader: A symbol indicating the type of input, can be either :files or :docs. Default is :files.\nseparators: A list of strings used as separators for splitting the text in each file into chunks. Default is [\\n\\n\", \". \", \"\\n\"].\nmax_length: The maximum length of each chunk (if possible with provided separators). Default is 256.\nsources: A vector of strings indicating the source of each chunk. Default is equal to files_or_docs (for reader=:files)\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.get_embeddings-Tuple{Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.get_embeddings","text":"get_embeddings(docs::Vector{<:AbstractString};\n    verbose::Bool = true,\n    cost_tracker = Threads.Atomic{Float64}(0.0),\n    target_batch_size_length::Int = 80_000,\n    ntasks::Int = 4 * Threads.nthreads(),\n    kwargs...)\n\nEmbeds a vector of docs using the provided model (kwarg model). \n\nTries to batch embedding calls for roughly 80K characters per call (to avoid exceeding the API limit) but reduce network latency.\n\nNotes\n\ndocs are assumed to be already chunked to the reasonable sizes that fit within the embedding context limit.\nIf you get errors about exceeding input sizes, first check the max_length in your chunks.  If that does NOT resolve the issue, try reducing the target_batch_size_length parameter (eg, 10_000) and number of tasks ntasks=1.  Some providers cannot handle large batch sizes.\n\nArguments\n\ndocs: A vector of strings to be embedded.\nverbose: A boolean flag for verbose output. Default is true.\nmodel: The model to use for embedding. Default is PT.MODEL_EMBEDDING.\ncost_tracker: A Threads.Atomic{Float64} object to track the total cost of the API calls. Useful to pass the total cost to the parent call.\ntarget_batch_size_length: The target length (in characters) of each batch of document chunks sent for embedding. Default is 80_000 characters. Speeds up embedding process.\nntasks: The number of tasks to use for asyncmap. Default is 4 * Threads.nthreads().\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.get_metadata-Tuple{Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.get_metadata","text":"get_metadata(docs::Vector{<:AbstractString};\n    verbose::Bool = true,\n    cost_tracker = Threads.Atomic{Float64}(0.0),\n    kwargs...)\n\nExtracts metadata from a vector of docs using the provided model (kwarg model).\n\nArguments\n\ndocs: A vector of strings to be embedded.\nverbose: A boolean flag for verbose output. Default is true.\nmodel: The model to use for metadata extraction. Default is PT.MODEL_CHAT.\nmetadata_template: A template to be used for metadata extraction. Default is :RAGExtractMetadataShort.\ncost_tracker: A Threads.Atomic{Float64} object to track the total cost of the API calls. Useful to pass the total cost to the parent call.\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.metadata_extract-Tuple{PromptingTools.Experimental.RAGTools.MetadataItem}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.metadata_extract","text":"metadata_extract(item::MetadataItem)\nmetadata_extract(items::Vector{MetadataItem})\n\nExtracts the metadata item into a string of the form category:::value (lowercased and spaces replaced with underscores).\n\nExample\n\nmsg = aiextract(:RAGExtractMetadataShort; return_type=MaybeMetadataItems, text=\"I like package DataFrames\", instructions=\"None.\")\nmetadata = metadata_extract(msg.content.items)\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.rerank-Tuple{PromptingTools.Experimental.RAGTools.CohereRerank, PromptingTools.Experimental.RAGTools.AbstractChunkIndex, Any, Any}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.rerank","text":"rerank(strategy::CohereRerank, index::AbstractChunkIndex, question,\n    candidate_chunks;\n    verbose::Bool = false,\n    api_key::AbstractString = PT.COHERE_API_KEY,\n    top_n::Integer = length(candidate_chunks.distances),\n    model::AbstractString = \"rerank-english-v2.0\",\n    return_documents::Bool = false,\n    kwargs...)\n\nRe-ranks a list of candidate chunks using the Cohere Rerank API. See https://cohere.com/rerank for more details. \n\nArguments\n\nquery: The query to be used for the search.\ndocuments: A vector of documents to be reranked.    The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000. We recommend less than 1000 documents for optimal performance.\ntop_n: The number of most relevant documents to return. Default is length(documents).\nmodel: The model to use for reranking. Default is rerank-english-v2.0.\nreturn_documents: A boolean flag indicating whether to return the reranked documents in the response. Default is false.\nmax_chunks_per_doc: The maximum number of chunks to use per document. Default is 10.\nverbose: A boolean flag indicating whether to print verbose logging. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.run_qa_evals-Tuple{PromptingTools.Experimental.RAGTools.AbstractChunkIndex, AbstractVector{<:PromptingTools.Experimental.RAGTools.QAEvalItem}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.run_qa_evals","text":"run_qa_evals(index::AbstractChunkIndex, qa_items::AbstractVector{<:QAEvalItem};\n    api_kwargs::NamedTuple = NamedTuple(),\n    airag_kwargs::NamedTuple = NamedTuple(),\n    qa_evals_kwargs::NamedTuple = NamedTuple(),\n    verbose::Bool = true, parameters_dict::Dict{Symbol, <:Any} = Dict{Symbol, Any}())\n\nEvaluates a vector of QAEvalItems and returns a vector QAEvalResult.  This function assesses the relevance and accuracy of the answers generated in a QA evaluation context.\n\nSee ?run_qa_evals for more details.\n\nArguments\n\nqa_items::AbstractVector{<:QAEvalItem}: The vector of QA evaluation items containing the questions and their answers.\nverbose::Bool: If true, enables verbose logging. Defaults to true.\napi_kwargs::NamedTuple: Parameters that will be forwarded to the API calls. See ?aiextract for details.\nairag_kwargs::NamedTuple: Parameters that will be forwarded to airag calls. See ?airag for details.\nqa_evals_kwargs::NamedTuple: Parameters that will be forwarded to run_qa_evals calls. See ?run_qa_evals for details.\nparameters_dict::Dict{Symbol, Any}: Track any parameters used for later evaluations. Keys must be Symbols.\n\nReturns\n\nVector{QAEvalResult}: Vector of evaluation results that includes various scores and metadata related to the QA evaluation.\n\nExample\n\nindex = \"...\" # Assuming a proper index is defined\nqa_items = [QAEvalItem(question=\"What is the capital of France?\", answer=\"Paris\", context=\"France is a country in Europe.\"),\n            QAEvalItem(question=\"What is the capital of Germany?\", answer=\"Berlin\", context=\"Germany is a country in Europe.\")]\n\n# Let's run a test with `top_k=5`\nresults = run_qa_evals(index, qa_items; airag_kwargs=(;top_k=5), parameters_dict=Dict(:top_k => 5))\n\n# Filter out the \"failed\" calls\nresults = filter(x->!isnothing(x.answer_score), results);\n\n# See average judge score\nmean(x->x.answer_score, results)\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.run_qa_evals-Tuple{PromptingTools.Experimental.RAGTools.QAEvalItem, PromptingTools.Experimental.RAGTools.RAGContext}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.run_qa_evals","text":"run_qa_evals(qa_item::QAEvalItem, ctx::RAGContext; verbose::Bool = true,\n             parameters_dict::Dict{Symbol, <:Any}, judge_template::Symbol = :RAGJudgeAnswerFromContext,\n             model_judge::AbstractString, api_kwargs::NamedTuple = NamedTuple()) -> QAEvalResult\n\nEvaluates a single QAEvalItem using a RAG context (RAGContext) and returns a QAEvalResult structure. This function assesses the relevance and accuracy of the answers generated in a QA evaluation context.\n\nArguments\n\nqa_item::QAEvalItem: The QA evaluation item containing the question and its answer.\nctx::RAGContext: The context used for generating the QA pair, including the original context and the answers. Comes from airag(...; return_context=true)\nverbose::Bool: If true, enables verbose logging. Defaults to true.\nparameters_dict::Dict{Symbol, Any}: Track any parameters used for later evaluations. Keys must be Symbols.\njudge_template::Symbol: The template symbol for the AI model used to judge the answer. Defaults to :RAGJudgeAnswerFromContext.\nmodel_judge::AbstractString: The AI model used for judging the answer's quality.  Defaults to standard chat model, but it is advisable to use more powerful model GPT-4.\napi_kwargs::NamedTuple: Parameters that will be forwarded to the API endpoint.\n\nReturns\n\nQAEvalResult: An evaluation result that includes various scores and metadata related to the QA evaluation.\n\nNotes\n\nThe function computes a retrieval score and rank based on how well the context matches the QA context.\nIt then uses the judge_template and model_judge to score the answer's accuracy and relevance.\nIn case of errors during evaluation, the function logs a warning (if verbose is true) and the answer_score will be set to nothing.\n\nExamples\n\nEvaluating a QA pair using a specific context and model:\n\nqa_item = QAEvalItem(question=\"What is the capital of France?\", answer=\"Paris\", context=\"France is a country in Europe.\")\nctx = RAGContext(source=\"Wikipedia\", context=\"France is a country in Europe.\", answer=\"Paris\")\nparameters_dict = Dict(\"param1\" => \"value1\", \"param2\" => \"value2\")\n\neval_result = run_qa_evals(qa_item, ctx, parameters_dict=parameters_dict, model_judge=\"MyAIJudgeModel\")\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.score_retrieval_hit-Tuple{AbstractString, Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.score_retrieval_hit","text":"Returns 1.0 if context overlaps or is contained within any of the candidate_context\n\n\n\n\n\n","category":"method"},{"location":"reference_ragtools/#PromptingTools.Experimental.RAGTools.score_retrieval_rank-Tuple{AbstractString, Vector{<:AbstractString}}","page":"RAGTools","title":"PromptingTools.Experimental.RAGTools.score_retrieval_rank","text":"Returns Integer rank of the position where context overlaps or is contained within a candidate_context\n\n\n\n\n\n","category":"method"},{"location":"reference_apitools/#Reference-for-APITools","page":"APITools","title":"Reference for APITools","text":"","category":"section"},{"location":"reference_apitools/","page":"APITools","title":"APITools","text":"Modules = [PromptingTools.Experimental.APITools]","category":"page"},{"location":"reference_apitools/","page":"APITools","title":"APITools","text":"Modules = [PromptingTools.Experimental.APITools]","category":"page"},{"location":"reference_apitools/#PromptingTools.Experimental.APITools.create_websearch-Tuple{AbstractString}","page":"APITools","title":"PromptingTools.Experimental.APITools.create_websearch","text":"create_websearch(query::AbstractString;\n    api_key::AbstractString,\n    search_depth::AbstractString = \"basic\")\n\nArguments\n\nquery::AbstractString: The query to search for.\napi_key::AbstractString: The API key to use for the search. Get an API key from Tavily.\nsearch_depth::AbstractString: The depth of the search. Can be either \"basic\" or \"advanced\". Default is \"basic\". Advanced search calls equal to 2 requests.\ninclude_answer::Bool: Whether to include the answer in the search results. Default is false.\ninclude_raw_content::Bool: Whether to include the raw content in the search results. Default is false.\nmax_results::Integer: The maximum number of results to return. Default is 5.\ninclude_images::Bool: Whether to include images in the search results. Default is false.\ninclude_domains::AbstractVector{<:AbstractString}: A list of domains to include in the search results. Default is an empty list.\nexclude_domains::AbstractVector{<:AbstractString}: A list of domains to exclude from the search results. Default is an empty list.\n\nExample\n\nr = create_websearch(\"Who is King Charles?\")\n\nEven better, you can get not just the results but also the answer:\n\nr = create_websearch(\"Who is King Charles?\"; include_answer = true)\n\nSee Rest API documentation for more information.\n\n\n\n\n\n","category":"method"},{"location":"reference_apitools/#PromptingTools.Experimental.APITools.tavily_api-Tuple{}","page":"APITools","title":"PromptingTools.Experimental.APITools.tavily_api","text":"tavily_api(;\n    api_key::AbstractString,\n    endpoint::String = \"search\",\n    url::AbstractString = \"https://api.tavily.com\",\n    http_kwargs::NamedTuple = NamedTuple(),\n    kwargs...)\n\nSends API requests to Tavily and returns the response.\n\n\n\n\n\n","category":"method"},{"location":"examples/working_with_custom_apis/#Custom-APIs","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"PromptingTools allows you to use any OpenAI-compatible API (eg, MistralAI), including a locally hosted one like the server from llama.cpp.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"using PromptingTools\nconst PT = PromptingTools","category":"page"},{"location":"examples/working_with_custom_apis/#Using-MistralAI","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using MistralAI","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Mistral models have long been dominating the open-source space. They are now available via their API, so you can use them with PromptingTools.jl!","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"msg = aigenerate(\"Say hi!\"; model=\"mistral-tiny\")\n# [ Info: Tokens: 114 @ Cost: $0.0 in 0.9 seconds\n# AIMessage(\"Hello there! I'm here to help answer any questions you might have, or assist you with tasks to the best of my abilities. How can I be of service to you today? If you have a specific question, feel free to ask and I'll do my best to provide accurate and helpful information. If you're looking for general assistance, I can help you find resources or information on a variety of topics. Let me know how I can help.\")","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"It all just works, because we have registered the models in the PromptingTools.MODEL_REGISTRY! There are currently 4 models available: mistral-tiny, mistral-small, mistral-medium, mistral-embed.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Under the hood, we use a dedicated schema MistralOpenAISchema that leverages most of the OpenAI-specific code base, so you can always provide that explicitly as the first argument:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"const PT = PromptingTools\nmsg = aigenerate(PT.MistralOpenAISchema(), \"Say Hi!\"; model=\"mistral-tiny\", api_key=ENV[\"MISTRALAI_API_KEY\"])","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"As you can see, we can load your API key either from the ENV or via the Preferences.jl mechanism (see ?PREFERENCES for more information).","category":"page"},{"location":"examples/working_with_custom_apis/#Using-other-OpenAI-compatible-APIs","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using other OpenAI-compatible APIs","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"MistralAI are not the only ones who mimic the OpenAI API! There are many other exciting providers, eg, Perplexity.ai, Fireworks.ai.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"As long as they are compatible with the OpenAI API (eg, sending messages with role and content keys), you can use them with PromptingTools.jl by using schema = CustomOpenAISchema():","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"# Set your API key and the necessary base URL for the API\napi_key = \"...\"\nprovider_url = \"...\" # provider API URL\nprompt = \"Say hi!\"\nmsg = aigenerate(PT.CustomOpenAISchema(), prompt; model=\"<some-model>\", api_key, api_kwargs=(; url=provider_url))","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"[!TIP] If you register the model names with PT.register_model!, you won't have to keep providing the schema manually.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Note: At the moment, we only support aigenerate and aiembed functions.","category":"page"},{"location":"examples/working_with_custom_apis/#Using-llama.cpp-server","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using llama.cpp server","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"In line with the above, you can also use the llama.cpp server. ","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"It is a bit more technically demanding because you need to \"compile\" llama.cpp first, but it will always have the latest models and it is quite fast (eg, faster than Ollama, which uses llama.cpp under the hood but has some extra overhead).","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Start your server in a command line (-m refers to the model file, -c is the context length, -ngl is the number of layers to offload to GPU):","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"./server -m models/mixtral-8x7b-instruct-v0.1.Q4_K_M.gguf -c 2048 -ngl 99","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Then simply access it via PromptingTools:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"msg = aigenerate(PT.CustomOpenAISchema(), \"Count to 5 and say hi!\"; api_kwargs=(; url=\"http://localhost:8080/v1\"))","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"[!TIP] If you register the model names with PT.register_model!, you won't have to keep providing the schema manually. It can be any model name, because the model is actually selected when you start the server in the terminal.","category":"page"},{"location":"examples/working_with_custom_apis/#Using-Databricks-Foundation-Models","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using Databricks Foundation Models","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"You can also use the Databricks Foundation Models API with PromptingTools.jl.  It requires you to set ENV variables DATABRICKS_API_KEY (often referred to as \"DATABRICKS TOKEN\") and DATABRICKS_HOST.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"The long way to use it is:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"msg = aigenerate(PT.DatabricksOpenAISchema(),\n    \"Say hi to the llama!\";\n    model = \"databricks-llama-2-70b-chat\",\n    api_key = ENV[\"DATABRICKS_API_KEY\"], api_kwargs = (; url=ENV[\"DATABRICKS_HOST\"]))","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"But you can also register the models you're hosting and use it as usual:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"# Quick registration of a model\nPT.register_model!(;\n        name = \"databricks-llama-2-70b-chat\",\n        schema = PT.DatabricksOpenAISchema())\nPT.MODEL_ALIASES[\"dllama\"] = \"databricks-llama-2-70b-chat\" # set alias to make your life easier\n\n# Simply call:\nmsg = aigenerate(\"Say hi to the llama!\"; model = \"dllama\")\n# Or even shorter\nai\"Say hi to the llama!\"dllama","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"You can use aiembed as well.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Find more information here.","category":"page"},{"location":"examples/working_with_custom_apis/#Using-Together.ai","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using Together.ai","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"You can also use the Together.ai API with PromptingTools.jl. It requires you to set ENV variable TOGETHER_API_KEY.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"The corresponding schema is TogetherOpenAISchema, but we have registered one model for you, so you can use it as usual. Alias \"tmixtral\" (T for Together.ai and mixtral for the model name) is already set for you.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"msg = aigenerate(\"Say hi\"; model=\"tmixtral\")\n## [ Info: Tokens: 87 @ Cost: \\$0.0001 in 5.1 seconds\n## AIMessage(\"Hello! I'm here to help you. Is there something specific you'd like to know or discuss? I can provide information on a wide range of topics, assist with tasks, and even engage in a friendly conversation. Let me know how I can best assist you today.\")","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"For embedding a text, use aiembed:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"aiembed(PT.TogetherOpenAISchema(), \"embed me\"; model=\"BAAI/bge-large-en-v1.5\")","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Note: You can register the model with PT.register_model! and use it as usual.","category":"page"},{"location":"examples/working_with_custom_apis/#Using-Fireworks.ai","page":"Custom APIs (Mistral, Llama.cpp)","title":"Using Fireworks.ai","text":"","category":"section"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"You can also use the Fireworks.ai API with PromptingTools.jl. It requires you to set ENV variable FIREWORKS_API_KEY.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"The corresponding schema is FireworksOpenAISchema, but we have registered one model for you, so you can use it as usual. Alias \"fmixtral\" (F for Fireworks.ai and mixtral for the model name) is already set for you.","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"msg = aigenerate(\"Say hi\"; model=\"fmixtral\")\n## [ Info: Tokens: 78 @ Cost: \\$0.0001 in 0.9 seconds\n## AIMessage(\"Hello! I'm glad you're here. I'm here to help answer any questions you have to the best of my ability. Is there something specific you'd like to know or discuss? I can assist with a wide range of topics, so feel free to ask me anything!\")","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"In addition, at the time of writing (23rd Feb 2024), Fireworks is providing access to their new function calling model (fine-tuned Mixtral) for free. ","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Try it with aiextract for structured extraction (model is aliased as firefunction):","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"\"\"\"\nExtract the food from the sentence. Extract any provided adjectives for the food as well.\n\nExample: \"I am eating a crunchy bread.\" -> Food(\"bread\", [\"crunchy\"])\n\"\"\"\nstruct Food\n    name::String\n    adjectives::Union{Nothing,Vector{String}}\nend\nprompt = \"I just ate a delicious and juicy apple.\"\nmsg = aiextract(prompt; return_type=Food, model=\"firefunction\")\nmsg.content\n# Output: Food(\"apple\", [\"delicious\", \"juicy\"])","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"For embedding a text, use aiembed:","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"aiembed(PT.FireworksOpenAISchema(), \"embed me\"; model=\"nomic-ai/nomic-embed-text-v1.5\")","category":"page"},{"location":"examples/working_with_custom_apis/","page":"Custom APIs (Mistral, Llama.cpp)","title":"Custom APIs (Mistral, Llama.cpp)","text":"Note: You can register the model with PT.register_model! and use it as usual.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"OpenAI API key saved in the environment variable OPENAI_API_KEY","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You will need to register with OpenAI and generate an API key:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Create an account with OpenAI\nGo to API Key page\nClick on “Create new secret key”","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"!!! Do not share it with anyone and do NOT save it to any files that get synced online.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Resources:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"OpenAI Documentation\nVisual tutorial","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You will need to set this key as an environment variable before using PromptingTools.jl:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For a quick start, simply set it via ENV[\"OPENAI_API_KEY\"] = \"your-api-key\" Alternatively, you can:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"set it in the terminal before launching Julia: export OPENAI_API_KEY = <your key>\nset it in your setup.jl (make sure not to commit it to GitHub!)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Make sure to start Julia from the same terminal window where you set the variable. Easy check in Julia, run ENV[\"OPENAI_API_KEY\"] and you should see your key!","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For other options or more robust solutions, see the FAQ section.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Resources: ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"OpenAI Guide","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"PromptingTools can be installed using the following commands:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"PromptingTools.jl\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Throughout the rest of this tutorial, we will assume that you have installed the PromptingTools package and have already typed using PromptingTools to bring all of the relevant variables into your current namespace.","category":"page"},{"location":"getting_started/#Quick-Start-with-@ai_str","page":"Getting Started","title":"Quick Start with @ai_str","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The easiest start is the @ai_str macro. Simply type ai\"your prompt\" and you will get a response from the default model (GPT-3.5 Turbo).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ai\"What is the capital of France?\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[ Info: Tokens: 31 @ Cost: $0.0 in 1.5 seconds --> Be in control of your spending! \nAIMessage(\"The capital of France is Paris.\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Returned object is a light wrapper with generated message in field :content (eg, ans.content) for additional downstream processing.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you want to reply to the previous message, or simply continue the conversation, use @ai!_str (notice the bang !):","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ai!\"And what is the population of it?\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can easily inject any variables with string interpolation:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"country = \"Spain\"\nai\"What is the capital of \\$(country)?\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[ Info: Tokens: 32 @ Cost: $0.0001 in 0.5 seconds\nAIMessage(\"The capital of Spain is Madrid.\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pro tip: Use after-string-flags to select the model to be called, eg, ai\"What is the capital of France?\"gpt4 (use gpt4t for the new GPT-4 Turbo model). Great for those extra hard questions!","category":"page"},{"location":"getting_started/#Using-aigenerate-with-placeholders","page":"Getting Started","title":"Using aigenerate with placeholders","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For more complex prompt templates, you can use handlebars-style templating and provide variables as keyword arguments:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"msg = aigenerate(\"What is the capital of {{country}}? Is the population larger than {{population}}?\", country=\"Spain\", population=\"1M\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[ Info: Tokens: 74 @ Cost: $0.0001 in 1.3 seconds\nAIMessage(\"The capital of Spain is Madrid. And yes, the population of Madrid is larger than 1 million. As of 2020, the estimated population of Madrid is around 3.3 million people.\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pro tip: Use asyncmap to run multiple AI-powered tasks concurrently.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pro tip: If you use slow models (like GPT-4), you can use the asynchronous version of @ai_str -> @aai_str to avoid blocking the REPL, eg, aai\"Say hi but slowly!\"gpt4 (similarly @ai!_str -> @aai!_str for multi-turn conversations).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For more practical examples, see the Various Examples section.","category":"page"},{"location":"frequently_asked_questions/#Frequently-Asked-Questions","page":"F.A.Q.","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"frequently_asked_questions/#Why-OpenAI","page":"F.A.Q.","title":"Why OpenAI","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI's models are at the forefront of AI research and provide robust, state-of-the-art capabilities for many tasks.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"There will be situations not or cannot use it (eg, privacy, cost, etc.). In that case, you can use local models (eg, Ollama) or other APIs (eg, Anthropic).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Note: To get started with Ollama.ai, see the Setup Guide for Ollama section below.","category":"page"},{"location":"frequently_asked_questions/#Data-Privacy-and-OpenAI","page":"F.A.Q.","title":"Data Privacy and OpenAI","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"At the time of writing, OpenAI does NOT use the API calls for training their models.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"APIOpenAI does not use data submitted to and generated by our API to train OpenAI models or improve OpenAI’s service offering. In order to support the continuous improvement of our models, you can fill out this form to opt-in to share your data with us. – How your data is used to improve our models","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You can always double-check the latest information on the OpenAI's How we use your data page.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Resources:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI's How we use your data\nData usage for consumer services FAQ\nHow your data is used to improve our models","category":"page"},{"location":"frequently_asked_questions/#Creating-OpenAI-API-Key","page":"F.A.Q.","title":"Creating OpenAI API Key","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You can get your API key from OpenAI by signing up for an account and accessing the API section of the OpenAI website.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Create an account with OpenAI\nGo to API Key page\nClick on “Create new secret key”","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"!!! Do not share it with anyone and do NOT save it to any files that get synced online.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Resources:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI Documentation\nVisual tutorial","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Pro tip: Always set the spending limits!","category":"page"},{"location":"frequently_asked_questions/#Getting-an-error-\"ArgumentError:-api*key-cannot-be-empty\"-despite-having-set-OPENAI*API_KEY?","page":"F.A.Q.","title":"Getting an error \"ArgumentError: apikey cannot be empty\" despite having set `OPENAIAPI_KEY`?","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Quick fix: just provide kwarg api_key with your key to the aigenerate function (and other ai* functions).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"This error is thrown when the OpenAI API key is not available in 1) local preferences or 2) environment variables (ENV[\"OPENAI_API_KEY\"]).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"First, check if you can access the key by running ENV[\"OPENAI_API_KEY\"] in the Julia REPL. If it returns nothing, the key is not set.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"If the key is set, but you still get the error, there was a rare bug in earlier versions where if you first precompiled PromptingTools without the API key, it would remember it and \"compile away\" the get(ENV,...) function call. If you're experiencing this bug on the latest version of PromptingTools, please open an issue on GitHub.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"The solution is to force a new precompilation, so you can do any of the below:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Force precompilation (run Pkg.precompile() in the Julia REPL)\nUpdate the PromptingTools package (runs precompilation automatically)\nDelete your compiled cache in .julia DEPOT (usually .julia/compiled/v1.10/PromptingTools). You can do it manually in the file explorer or via Julia REPL: rm(\"~/.julia/compiled/v1.10/PromptingTools\", recursive=true, force=true)","category":"page"},{"location":"frequently_asked_questions/#Setting-OpenAI-Spending-Limits","page":"F.A.Q.","title":"Setting OpenAI Spending Limits","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI allows you to set spending limits directly on your account dashboard to prevent unexpected costs.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Go to OpenAI Billing\nSet Soft Limit (you’ll receive a notification) and Hard Limit (API will stop working not to spend more money)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"A good start might be a soft limit of c.5 and a hard limit of c10 - you can always increase it later in the month.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Resources:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI Forum","category":"page"},{"location":"frequently_asked_questions/#How-much-does-it-cost?-Is-it-worth-paying-for?","page":"F.A.Q.","title":"How much does it cost? Is it worth paying for?","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"If you use a local model (eg, with Ollama), it's free. If you use any commercial APIs (eg, OpenAI), you will likely pay per \"token\" (a sub-word unit).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"For example, a simple request with a simple question and 1 sentence response in return (”Is statement XYZ a positive comment”) will cost you ~0.0001 (ie, one-hundredth of a cent)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Is it worth paying for?","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"GenAI is a way to buy time! You can pay cents to save tens of minutes every day.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Continuing the example above, imagine you have a table with 200 comments. Now, you can parse each one of them with an LLM for the features/checks you need.  Assuming the price per call was 0.0001, you'd pay 2 cents for the job and save 30-60 minutes of your time!","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Resources:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI Pricing per 1000 tokens","category":"page"},{"location":"frequently_asked_questions/#Configuring-the-Environment-Variable-for-API-Key","page":"F.A.Q.","title":"Configuring the Environment Variable for API Key","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"This is a guide for OpenAI's API key, but it works for any other API key you might need (eg, MISTRALAI_API_KEY for MistralAI API).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"To use the OpenAI API with PromptingTools.jl, set your API key as an environment variable:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"ENV[\"OPENAI_API_KEY\"] = \"your-api-key\"","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"As a one-off, you can: ","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"set it in the terminal before launching Julia: export OPENAI_API_KEY = <your key>\nset it in your setup.jl (make sure not to commit it to GitHub!)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Make sure to start Julia from the same terminal window where you set the variable. Easy check in Julia, run ENV[\"OPENAI_API_KEY\"] and you should see your key!","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"A better way:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"On a Mac, add the configuration line to your terminal's configuration file (eg, ~/.zshrc). It will get automatically loaded every time you launch the terminal\nOn Windows, set it as a system variable in \"Environment Variables\" settings (see the Resources)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Resources: ","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"OpenAI Guide","category":"page"},{"location":"frequently_asked_questions/#Setting-the-API-Key-via-Preferences.jl","page":"F.A.Q.","title":"Setting the API Key via Preferences.jl","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You can also set the API key in LocalPreferences.toml, so it persists across sessions and projects.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Use: PromptingTools.set_preferences!(\"OPENAI_API_KEY\"=\"your-api-key\")","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"To double-check, run PromptingTools.get_preferences(\"OPENAI_API_KEY\") and you should see your key!","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"See more detail in the ?PromptingTools.PREFERENCES docstring.","category":"page"},{"location":"frequently_asked_questions/#Understanding-the-API-Keyword-Arguments-in-aigenerate-(api_kwargs)","page":"F.A.Q.","title":"Understanding the API Keyword Arguments in aigenerate (api_kwargs)","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"See OpenAI API reference for more information.","category":"page"},{"location":"frequently_asked_questions/#Instant-Access-from-Anywhere","page":"F.A.Q.","title":"Instant Access from Anywhere","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"For easy access from anywhere, add PromptingTools into your startup.jl (can be found in ~/.julia/config/startup.jl).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Add the following snippet:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"using PromptingTools\nconst PT = PromptingTools # to access unexported functions and types","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Now, you can just use ai\"Help me do X to achieve Y\" from any REPL session!","category":"page"},{"location":"frequently_asked_questions/#Open-Source-Alternatives","page":"F.A.Q.","title":"Open Source Alternatives","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"The ethos of PromptingTools.jl is to allow you to use whatever model you want, which includes Open Source LLMs. The most popular and easiest to setup is Ollama.ai - see below for more information.","category":"page"},{"location":"frequently_asked_questions/#Setup-Guide-for-Ollama","page":"F.A.Q.","title":"Setup Guide for Ollama","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Ollama runs a background service hosting LLMs that you can access via a simple API. It's especially useful when you're working with some sensitive data that should not be sent anywhere.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Installation is very easy, just download the latest version here.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Once you've installed it, just launch the app and you're ready to go!","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"To check if it's running, go to your browser and open 127.0.0.1:11434. You should see the message \"Ollama is running\".  Alternatively, you can run ollama serve in your terminal and you'll get a message that it's already running.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"There are many models available in Ollama Library, including Llama2, CodeLlama, SQLCoder, or my personal favorite openhermes2.5-mistral.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Download new models with ollama pull <model_name> (eg, ollama pull openhermes2.5-mistral). ","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Show currently available models with ollama list.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"See Ollama.ai for more information.","category":"page"},{"location":"frequently_asked_questions/#Changing-the-Default-Model-or-Schema","page":"F.A.Q.","title":"Changing the Default Model or Schema","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"If you tend to use non-default options, it can get tedious to specify PT.* every time.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"There are three ways how you can customize your workflows (especially when you use Ollama or other local models):","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Import the functions/types you need explicitly at the top (eg, using PromptingTools: OllamaSchema)\nRegister your model and its associated schema  (PT.register_model!(; name=\"123\", schema=PT.OllamaSchema())). You won't have to specify the schema anymore only the model name. See Working with Ollama for more information.\nOverride your default model (PT.MODEL_CHAT) and schema (PT.PROMPT_SCHEMA). It can be done persistently with Preferences, eg, PT.set_preferences!(\"PROMPT_SCHEMA\" => \"OllamaSchema\", \"MODEL_CHAT\"=>\"llama2\").","category":"page"},{"location":"frequently_asked_questions/#How-to-have-Multi-turn-Conversations?","page":"F.A.Q.","title":"How to have Multi-turn Conversations?","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Let's say you would like to respond back to a model's response. How to do it?","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"With ai\"\" macro","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"The simplest way if you used ai\"\" macro, is to send a reply with the ai!\"\" macro. It will use the last response as the conversation.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"ai\"Hi! I'm John\"\n\nai!\"What's my name?\"\n# Return: \"Your name is John.\"","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"With aigenerate function","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You can use the conversation keyword argument to pass the previous conversation (in all ai* functions). It will prepend the past conversation before sending the new request to the model.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"To get the conversation, set return_all=true and store the whole conversation thread (not just the last message) in a variable. Then, use it as a keyword argument in the next call.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"conversation = aigenerate(\"Hi! I'm John\"; return_all=true)\n@info last(conversation) # display the response\n\n# follow-up (notice that we provide past messages as conversation kwarg\nconversation = aigenerate(\"What's my name?\"; return_all=true, conversation)\n\n## [ Info: Tokens: 50 @ Cost: $0.0 in 1.0 seconds\n## 5-element Vector{PromptingTools.AbstractMessage}:\n##  PromptingTools.SystemMessage(\"Act as a helpful AI assistant\")\n##  PromptingTools.UserMessage(\"Hi! I'm John\")\n##  AIMessage(\"Hello John! How can I assist you today?\")\n##  PromptingTools.UserMessage(\"What's my name?\")\n##  AIMessage(\"Your name is John.\")","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Notice that the last message is the response to the second request, but with return_all=true we can see the whole conversation from the beginning.","category":"page"},{"location":"frequently_asked_questions/#Explain-What-Happens-Under-the-Hood","page":"F.A.Q.","title":"Explain What Happens Under the Hood","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"4 Key Concepts/Objects:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Schemas -> object of type AbstractPromptSchema that determines which methods are called and, hence, what providers/APIs are used\nPrompts -> the information you want to convey to the AI model\nMessages -> the basic unit of communication between the user and the AI model (eg, UserMessage vs AIMessage)\nPrompt Templates -> re-usable \"prompts\" with placeholders that you can replace with your inputs at the time of making the request","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"When you call aigenerate, roughly the following happens: render -> UserMessage(s) -> render -> OpenAI.create_chat -> ... -> AIMessage.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"We'll deep dive into an example in the end.","category":"page"},{"location":"frequently_asked_questions/#Schemas","page":"F.A.Q.","title":"Schemas","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"For your \"message\" to reach an AI model, it needs to be formatted and sent to the right place.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"We leverage the multiple dispatch around the \"schemas\" to pick the right logic. All schemas are subtypes of AbstractPromptSchema and there are many subtypes, eg, OpenAISchema <: AbstractOpenAISchema <:AbstractPromptSchema.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"For example, if you provide schema = OpenAISchema(), the system knows that:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"it will have to format any user inputs to OpenAI's \"message specification\" (a vector of dictionaries, see their API documentation). Function render(OpenAISchema(),...) will take care of the rendering.\nit will have to send the message to OpenAI's API. We will use the amazing OpenAI.jl package to handle the communication.","category":"page"},{"location":"frequently_asked_questions/#Prompts","page":"F.A.Q.","title":"Prompts","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Prompt is loosely the information you want to convey to the AI model. It can be a question, a statement, or a command. It can have instructions or some context, eg, previous conversation.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You need to remember that Large Language Models (LLMs) are stateless. They don't remember the previous conversation/request, so you need to provide the whole history/context every time (similar to how REST APIs work).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Prompts that we send to the LLMs are effectively a sequence of messages (<:AbstractMessage).","category":"page"},{"location":"frequently_asked_questions/#Messages","page":"F.A.Q.","title":"Messages","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Messages are the basic unit of communication between the user and the AI model. ","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"There are 5 main types of messages (<:AbstractMessage):","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"SystemMessage - this contains information about the \"system\", eg, how it should behave, format its output, etc. (eg, `You're a world-class Julia programmer. You write brief and concise code.)\nUserMessage - the information \"from the user\", ie, your question/statement/task\nUserMessageWithImages - the same as UserMessage, but with images (URLs or Base64-encoded images)\nAIMessage - the response from the AI model, when the \"output\" is text\nDataMessage - the response from the AI model, when the \"output\" is data, eg, embeddings with aiembed or user-defined structs with aiextract","category":"page"},{"location":"frequently_asked_questions/#Prompt-Templates","page":"F.A.Q.","title":"Prompt Templates","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"We want to have re-usable \"prompts\", so we provide you with a system to retrieve pre-defined prompts with placeholders (eg, {{name}}) that you can replace with your inputs at the time of making the request.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"\"AI Templates\" as we call them (AITemplate) are usually a vector of SystemMessage and a UserMessage with specific purpose/task.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"For example, the template :AssistantAsk is defined loosely as:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":" template = [SystemMessage(\"You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\"),\n             UserMessage(\"# Question\\n\\n{{ask}}\")]","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Notice that we have a placeholder ask ({{ask}}) that you can replace with your question without having to re-write the generic system instructions.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"When you provide a Symbol (eg, :AssistantAsk) to ai* functions, thanks to the multiple dispatch, it recognizes that it's an AITemplate(:AssistantAsk) and looks it up.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"You can discover all available templates with aitemplates(\"some keyword\") or just see the details of some template aitemplates(:AssistantAsk).","category":"page"},{"location":"frequently_asked_questions/#Walkthrough-Example","page":"F.A.Q.","title":"Walkthrough Example","text":"","category":"section"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"using PromptingTools\nconst PT = PromptingTools\n\n# Let's say this is our ask\nmsg = aigenerate(:AssistantAsk; ask=\"What is the capital of France?\")\n\n# it is effectively the same as:\nmsg = aigenerate(PT.OpenAISchema(), PT.AITemplate(:AssistantAsk); ask=\"What is the capital of France?\", model=\"gpt3t\")","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"There is no model provided, so we use the default PT.MODEL_CHAT (effectively GPT3.5-Turbo). Then we look it up in PT.MDOEL_REGISTRY and use the associated schema for it (OpenAISchema in this case).","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"The next step is to render the template, replace the placeholders and render it for the OpenAI model.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"# Let's remember out schema\nschema = PT.OpenAISchema()\nask = \"What is the capital of France?\"","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"First, we obtain the template (no placeholder replacement yet) and \"expand it\"","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"template_rendered = PT.render(schema, AITemplate(:AssistantAsk); ask)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"2-element Vector{PromptingTools.AbstractChatMessage}:\n  PromptingTools.SystemMessage(\"You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\")\n  PromptingTools.UserMessage{String}(\"# Question\\n\\n{{ask}}\", [:ask], :usermessage)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Second, we replace the placeholders","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"rendered_for_api = PT.render(schema, template_rendered;  ask)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"2-element Vector{Dict{String, Any}}:\n  Dict(\"role\" => \"system\", \"content\" => \"You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.\")\n  Dict(\"role\" => \"user\", \"content\" => \"# Question\\n\\nWhat is the capital of France?\")","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Notice that the placeholders are only replaced in the second step. The final output here is a vector of messages with \"role\" and \"content\" keys, which is the format required by the OpenAI API.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"As a side note, under the hood, the second step is done in two steps:","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"replace the placeholders messages_rendered = PT.render(PT.NoSchema(), template_rendered; ask) -> returns a vector of Messages!\nthen, we convert the messages to the format required by the provider/schema PT.render(schema, messages_rendered) -> returns the OpenAI formatted messages","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"Next, we send the above rendered_for_api to the OpenAI API and get the response back.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"using OpenAI\nOpenAI.create_chat(api_key, model, rendered_for_api)","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"The last step is to take the JSON response from the API and convert it to the AIMessage object.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"# simplification for educational purposes\nmsg = AIMessage(; content = r.response[:choices][1][:message][:content])","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"In practice, there are more fields we extract, so we define a utility for it: PT.response_to_message. Especially, since with parameter n, you can request multiple AI responses at once, so we want to re-use our response processing logic.","category":"page"},{"location":"frequently_asked_questions/","page":"F.A.Q.","title":"F.A.Q.","text":"That's it! I hope you've learned something new about how PromptingTools.jl works under the hood.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PromptingTools","category":"page"},{"location":"#PromptingTools","page":"Home","title":"PromptingTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PromptingTools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Streamline your life using PromptingTools.jl, the Julia package that simplifies interacting with large language models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PromptingTools.jl is not meant for building large-scale systems. It's meant to be the go-to tool in your global environment that will save you 20 minutes every day!","category":"page"},{"location":"#Why-PromptingTools.jl?","page":"Home","title":"Why PromptingTools.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Prompt engineering is neither fast nor easy. Moreover, different models and their fine-tunes might require different prompt formats and tricks, or perhaps the information you work with requires special models to be used. PromptingTools.jl is meant to unify the prompts for different backends and make the common tasks (like templated prompts) as simple as possible. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"aigenerate Function: Simplify prompt templates with handlebars (eg, {{variable}}) and keyword arguments\n@ai_str String Macro: Save keystrokes with a string macro for simple prompts\nEasy to Remember: All exported functions start with ai... for better discoverability\nLight Wrapper Types: Benefit from Julia's multiple dispatch by having AI outputs wrapped in specific types\nMinimal Dependencies: Enjoy an easy addition to your global environment with very light dependencies\nNo Context Switching: Access cutting-edge LLMs with no context switching and minimum extra keystrokes directly in your REPL","category":"page"},{"location":"#First-Steps","page":"Home","title":"First Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started, see the Getting Started section.","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"EditURL = \"../../../examples/building_RAG.jl\"","category":"page"},{"location":"examples/building_RAG/#Building-a-Simple-Retrieval-Augmented-Generation-(RAG)-System-with-RAGTools","page":"Building RAG Application","title":"Building a Simple Retrieval-Augmented Generation (RAG) System with RAGTools","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's build a Retrieval-Augmented Generation (RAG) chatbot, tailored to navigate and interact with the DataFrames.jl documentation.  \"RAG\" is probably the most common and valuable pattern in Generative AI at the moment.","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"If you're not familiar with \"RAG\", start with this article.","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"using LinearAlgebra, SparseArrays\nusing PromptingTools\nusing PromptingTools.Experimental.RAGTools\n## Note: RAGTools module is still experimental and will change in the future. Ideally, they will be cleaned up and moved to a dedicated package\nusing JSON3, Serialization, DataFramesMeta\nusing Statistics: mean\nconst PT = PromptingTools\nconst RT = PromptingTools.Experimental.RAGTools","category":"page"},{"location":"examples/building_RAG/#RAG-in-Two-Lines","page":"Building RAG Application","title":"RAG in Two Lines","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's put together a few text pages from DataFrames.jl docs.  Simply go to DataFrames.jl docs and copy&paste a few pages into separate text files. Save them in the examples/data folder (see some example pages provided). Ideally, delete all the noise (like headers, footers, etc.) and keep only the text you want to use for the chatbot. Remember, garbage in, garbage out!","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"files = [\n    joinpath(\"examples\", \"data\", \"database_style_joins.txt\"),\n    joinpath(\"examples\", \"data\", \"what_is_dataframes.txt\"),\n]\n# Build an index of chunks, embed them, and create a lookup index of metadata/tags for each chunk\nindex = build_index(files; extract_metadata = false);","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's ask a question","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"# Embeds the question, finds the closest chunks in the index, and generates an answer from the closest chunks\nanswer = airag(index; question = \"I like dplyr, what is the equivalent in Julia?\")","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"AIMessage(\"The equivalent package in Julia to dplyr in R is DataFramesMeta.jl. It provides convenience functions for data manipulation with syntax similar to dplyr.\")","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"First RAG in two lines? Done!","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"What does it do?","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"build_index will chunk the documents into smaller pieces, embed them into numbers (to be able to judge the similarity of chunks) and, optionally, create a lookup index of metadata/tags for each chunk)\nindex is the result of this step and it holds your chunks, embeddings, and other metadata! Just show it :)\nairag will\nembed your question\nfind the closest chunks in the index (use parameters top_k and minimum_similarity to tweak the \"relevant\" chunks)\n[OPTIONAL] extracts any potential tags/filters from the question and applies them to filter down the potential candidates (use extract_metadata=true in build_index, you can also provide some filters explicitly via tag_filter)\n[OPTIONAL] re-ranks the candidate chunks (define and provide your own rerank_strategy, eg Cohere ReRank API)\nbuild a context from the closest chunks (use chunks_window_margin to tweak if we include preceding and succeeding chunks as well, see ?build_context for more details)\ngenerate an answer from the closest chunks (use return_context=true to see under the hood and debug your application)","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"You should save the index for later to avoid re-embedding / re-extracting the document chunks!","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"serialize(\"examples/index.jls\", index)\nindex = deserialize(\"examples/index.jls\");","category":"page"},{"location":"examples/building_RAG/#Evaluations","page":"Building RAG Application","title":"Evaluations","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"However, we want to evaluate the quality of the system. For that, we need a set of questions and answers. Ideally, we would handcraft a set of high-quality Q&A pairs. However, this is time-consuming and expensive. Let's generate them from the chunks in our index!","category":"page"},{"location":"examples/building_RAG/#Generate-Q-and-A-pairs","page":"Building RAG Application","title":"Generate Q&A pairs","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"We need to provide: chunks and sources (file paths for future reference)","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"evals = build_qa_evals(RT.chunks(index),\n    RT.sources(index);\n    instructions = \"None.\",\n    verbose = true);","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"[ Info: Q&A Sets built! (cost: $0.102)\n","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"[!TIP] In practice, you would review each item in this golden evaluation set (and delete any generic/poor questions). It will determine the future success of your app, so you need to make sure it's good!","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"# Save the evals for later\nJSON3.write(\"examples/evals.json\", evals)\nevals = JSON3.read(\"examples/evals.json\", Vector{RT.QAEvalItem});","category":"page"},{"location":"examples/building_RAG/#Explore-one-Q-and-A-pair","page":"Building RAG Application","title":"Explore one Q&A pair","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's explore one evals item – it's not the best quality but gives you the idea!","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"evals[1]","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"QAEvalItem:\n source: examples/data/database_style_joins.txt\n context: Database-Style Joins\nIntroduction to joins\nWe often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:\n\njulia> using DataFrames\n question: What is the purpose of joining two or more data sets together?\n answer: The purpose of joining two or more data sets together is to provide a complete picture of the topic being studied.\n","category":"page"},{"location":"examples/building_RAG/#Evaluate-this-Q-and-A-pair","page":"Building RAG Application","title":"Evaluate this Q&A pair","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's evaluate this QA item with a \"judge model\" (often GPT-4 is used as a judge).","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"# Note: that we used the same question, but generated a different context and answer via `airag`\nmsg, ctx = airag(index; evals[1].question, return_context = true);\n# ctx is a RAGContext object that keeps all intermediate states of the RAG pipeline for easy evaluation\njudged = aiextract(:RAGJudgeAnswerFromContext;\n    ctx.context,\n    ctx.question,\n    ctx.answer,\n    return_type = RT.JudgeAllScores)\njudged.content","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Dict{Symbol, Any} with 6 entries:\n  :final_rating => 4.8\n  :clarity => 5\n  :completeness => 4\n  :relevance => 5\n  :consistency => 5\n  :helpfulness => 5","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"We can also run the generation + evaluation in a function (a few more metrics are available, eg, retrieval score):","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"x = run_qa_evals(evals[10], ctx;\n    parameters_dict = Dict(:top_k => 3), verbose = true, model_judge = \"gpt4t\")","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"QAEvalResult:\n source: examples/data/database_style_joins.txt\n context: outerjoin: the output contains rows for values of the key that exist in any of the passed data frames.\nsemijoin: Like an inner join, but output is restricted to columns from the first (left) argument.\n question: What is the difference between outer join and semi join?\n answer: The purpose of joining two or more data sets together is to combine them in order to provide a complete picture or analysis of a specific topic or dataset. By joining data sets, we can combine information from multiple sources to gain more insights and make more informed decisions.\n retrieval_score: 0.0\n retrieval_rank: nothing\n answer_score: 5\n parameters: Dict(:top_k => 3)\n","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Fortunately, we don't have to do this one by one – let's evaluate all our Q&A pairs at once.","category":"page"},{"location":"examples/building_RAG/#Evaluate-the-Whole-Set","page":"Building RAG Application","title":"Evaluate the Whole Set","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Let's run each question & answer through our eval loop in async (we do it only for the first 10 to save time). See the ?airag for which parameters you can tweak, eg, top_k","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"results = asyncmap(evals[1:10]) do qa_item\n    # Generate an answer -- often you want the model_judge to be the highest quality possible, eg, \"GPT-4 Turbo\" (alias \"gpt4t)\n    msg, ctx = airag(index; qa_item.question, return_context = true,\n        top_k = 3, verbose = false, model_judge = \"gpt4t\")\n    # Evaluate the response\n    # Note: you can log key parameters for easier analysis later\n    run_qa_evals(qa_item, ctx; parameters_dict = Dict(:top_k => 3), verbose = false)\nend\n## Note that the \"failed\" evals can show as \"nothing\" (failed as in there was some API error or parsing error), so make sure to handle them.\nresults = filter(x->!isnothing(x.answer_score), results);","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Note: You could also use the vectorized version results = run_qa_evals(evals) to evaluate all items at once.","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"\n# Let's take a simple average to calculate our score\n@info \"RAG Evals: $(length(results)) results, Avg. score: $(round(mean(x->x.answer_score, results);digits=1)), Retrieval score: $(100*round(Int,mean(x->x.retrieval_score,results)))%\"","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"[ Info: RAG Evals: 10 results, Avg. score: 4.6, Retrieval score: 100%\n","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Note: The retrieval score is 100% only because we have two small documents and running on 10 items only. In practice, you would have a much larger document set and a much larger eval set, which would result in a more representative retrieval score.","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"You can also analyze the results in a DataFrame:","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"df = DataFrame(results)","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"<div><div style = \"float: left;\"><span>10×8 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">source</th><th style = \"text-align: left;\">context</th><th style = \"text-align: left;\">question</th><th style = \"text-align: left;\">answer</th><th style = \"text-align: left;\">retrieval_score</th><th style = \"text-align: left;\">retrieval_rank</th><th style = \"text-align: left;\">answer_score</th><th style = \"text-align: left;\">parameters</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"String\" style = \"text-align: left;\">String</th><th title = \"String\" style = \"text-align: left;\">String</th><th title = \"String\" style = \"text-align: left;\">String</th><th title = \"SubString{String}\" style = \"text-align: left;\">SubStrin…</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Int64\" style = \"text-align: left;\">Int64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Dict{Symbol, Int64}\" style = \"text-align: left;\">Dict…</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">Database-Style Joins\\nIntroduction to joins\\nWe often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:\\n\\njulia&gt; using DataFrames</td><td style = \"text-align: left;\">What is the purpose of joining two or more data sets together?</td><td style = \"text-align: left;\">The purpose of joining two or more data sets together is to combine the data sets based on a common key and provide a complete picture of the topic being studied.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">5.0</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">julia&gt; people = DataFrame(ID=[20, 40], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;])\\n2×2 DataFrame\\n Row │ ID     Name\\n     │ Int64  String\\n─────┼─────────────────\\n   1 │    20  John Doe\\n   2 │    40  Jane Doe</td><td style = \"text-align: left;\">What is the DataFrame called &apos;people&apos; composed of?</td><td style = \"text-align: left;\">The DataFrame called &apos;people&apos; consists of two columns: &apos;ID&apos; and &apos;Name&apos;. The &apos;ID&apos; column contains integers, and the &apos;Name&apos; column contains strings.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.0</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">3</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">julia&gt; jobs = DataFrame(ID=[20, 40], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;])\\n2×2 DataFrame\\n Row │ ID     Job\\n     │ Int64  String\\n─────┼───────────────\\n   1 │    20  Lawyer\\n   2 │    40  Doctor</td><td style = \"text-align: left;\">What are the jobs and IDs listed in the dataframe?</td><td style = \"text-align: left;\">The jobs and IDs listed in the dataframe are as follows:\\n\\nID: 20\\nJob: Lawyer\\n\\nID: 40\\nJob: Doctor</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.67</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">4</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the innerjoin function:</td><td style = \"text-align: left;\">How can we combine the names and jobs for each ID in a larger data set?</td><td style = \"text-align: left;\">We can use the `innerjoin` function to combine the names and jobs for each ID in a larger data set.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.33333</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">5</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">julia&gt; innerjoin(people, jobs, on = :ID)\\n2×3 DataFrame\\n Row │ ID     Name      Job\\n     │ Int64  String    String\\n─────┼─────────────────────────\\n   1 │    20  John Doe  Lawyer\\n   2 │    40  Jane Doe  Doctor</td><td style = \"text-align: left;\">What is the name of the person with the ID 40 and their job?</td><td style = \"text-align: left;\">The name of the person with the ID 40 is Jane Doe and their job is Doctor.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">2</td><td style = \"text-align: right;\">4.67</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">6</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.\\n\\nThe following functions are provided to perform seven kinds of joins:</td><td style = \"text-align: left;\">What are the different kinds of joins?</td><td style = \"text-align: left;\">The different kinds of joins are:\\n\\n1. Inner Join: Returns only the rows that have matching values in both data frames.\\n2. Left Join: Returns all rows from the left data frame and the matching rows from the right data frame.\\n3. Right Join: Returns all rows from the right data frame and the matching rows from the left data frame.\\n4. Full Outer Join: Returns all rows from both data frames and fills in missing values with null.\\n5. Cross Join: Returns the cartesian product of the rows from both data frames.\\n6. Semi Join: Returns only the rows from the left data frame that have matching values in the right data frame.\\n7. Anti Join: Returns only the rows from the left data frame that do not have matching values in the right data frame.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.66667</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">7</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">innerjoin: the output contains rows for values of the key that exist in all passed data frames.</td><td style = \"text-align: left;\">What does the output of the inner join operation contain?</td><td style = \"text-align: left;\">The output of the inner join operation contains only the rows for values of the key that exist in all passed data frames.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">5.0</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">8</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">leftjoin: the output contains rows for values of the key that exist in the first (left) argument, whether or not that value exists in the second (right) argument.</td><td style = \"text-align: left;\">What is the purpose of the left join operation?</td><td style = \"text-align: left;\">The purpose of the left join operation is to combine data from two tables based on a common key, where all rows from the left (first) table are included in the output, regardless of whether there is a match in the right (second) table.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.66667</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">9</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">rightjoin: the output contains rows for values of the key that exist in the second (right) argument, whether or not that value exists in the first (left) argument.</td><td style = \"text-align: left;\">What is the purpose of the right join operation?</td><td style = \"text-align: left;\">The purpose of the right join operation is to include all the rows from the second (right) argument, regardless of whether a match is found in the first (left) argument.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.67</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">10</td><td style = \"text-align: left;\">examples/data/database_style_joins.txt</td><td style = \"text-align: left;\">outerjoin: the output contains rows for values of the key that exist in any of the passed data frames.\\nsemijoin: Like an inner join, but output is restricted to columns from the first (left) argument.</td><td style = \"text-align: left;\">What is the difference between outer join and semi join?</td><td style = \"text-align: left;\">The difference between outer join and semi join is that outer join includes rows for values of the key that exist in any of the passed data frames, whereas semi join is like an inner join but only outputs columns from the first argument.</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1</td><td style = \"text-align: right;\">4.66667</td><td style = \"text-align: left;\">Dict(:top_k=&gt;3)</td></tr></tbody></table></div>","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"We're done for today!","category":"page"},{"location":"examples/building_RAG/#What-would-we-do-next?","page":"Building RAG Application","title":"What would we do next?","text":"","category":"section"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"Review your evaluation golden data set and keep only the good items\nPlay with the chunk sizes (maxlength in buildindex) and see how it affects the quality\nExplore using metadata/key filters (extract_metadata=true in build_index)\nAdd filtering for semantic similarity (embedding distance) to make sure we don't pick up irrelevant chunks in the context\nUse multiple indices or a hybrid index (add a simple BM25 lookup from TextAnalysis.jl)\nData processing is the most important step - properly parsed and split text could make wonders\nAdd re-ranking of context (see rerank function, you can use Cohere ReRank API)\nImprove the question embedding (eg, rephrase it, generate hypothetical answers and use them to find better context)","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"... and much more! See some ideas in Anyscale RAG tutorial","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"","category":"page"},{"location":"examples/building_RAG/","page":"Building RAG Application","title":"Building RAG Application","text":"This page was generated using Literate.jl.","category":"page"}]
}
